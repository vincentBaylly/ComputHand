{"results":[{"id":"153485313","type":"page","status":"current","title":"Java Initial","macroRenderedOutput":{},"body":{"view":{"value":"<div class=\"toc-macro client-side-toc-macro  conf-macro output-block\" data-headerelements=\"H1,H2,H3,H4,H5,H6,H7\" data-hasbody=\"false\" data-macro-name=\"toc\" data-macro-id=\"a4d84b32-95ff-4178-ba83-7faf9e26817b\" data-layout=\"default\" ac:local-id=\"795074e2-aefe-44fd-8d9c-c2be33924134\"> </div><h1 id=\"JavaInitial-Miseenplacedel’environnementdedéveloppement\"><strong>Mise en place de l’environnement de développement</strong></h1><h2 id=\"JavaInitial-Qu&#39;est-cequeduJava?\"><strong>Qu'est-ce que du Java ?</strong></h2><h3 id=\"JavaInitial-Lelanguage:\">Le language:</h3><p><strong>Java</strong> est un<a href=\"https://fr.wikipedia.org/wiki/Langage_de_programmation\" class=\"external-link\" rel=\"nofollow\"> langage de programmation</a><a href=\"https://fr.wikipedia.org/wiki/Programmation_orient%C3%A9e_objet\" class=\"external-link\" rel=\"nofollow\"> orienté objet</a> créé par<a href=\"https://fr.wikipedia.org/wiki/James_Gosling\" class=\"external-link\" rel=\"nofollow\"> James Gosling</a> et<a href=\"https://fr.wikipedia.org/wiki/Patrick_Naughton\" class=\"external-link\" rel=\"nofollow\"> Patrick Naughton</a>, employés de<a href=\"https://fr.wikipedia.org/wiki/Sun_Microsystems\" class=\"external-link\" rel=\"nofollow\"> Sun Microsystems</a>, avec le soutien de<a href=\"https://fr.wikipedia.org/wiki/Bill_Joy\" class=\"external-link\" rel=\"nofollow\"> Bill Joy</a> (cofondateur de<a href=\"https://fr.wikipedia.org/wiki/Sun_Microsystems\" class=\"external-link\" rel=\"nofollow\"> Sun Microsystems</a> en<a href=\"https://fr.wikipedia.org/wiki/1982\" class=\"external-link\" rel=\"nofollow\"> 1982</a>), présenté officiellement le<a href=\"https://fr.wikipedia.org/wiki/23_mai\" class=\"external-link\" rel=\"nofollow\"> 23</a><a href=\"https://fr.wikipedia.org/wiki/Mai_1995\" class=\"external-link\" rel=\"nofollow\"> mai</a><a href=\"https://fr.wikipedia.org/wiki/1995_en_informatique\" class=\"external-link\" rel=\"nofollow\"> 1995</a> au <em>SunWorld</em>.</p><p>La société Sun a été ensuite rachetée en 2009 par la société<a href=\"https://fr.wikipedia.org/wiki/Oracle_(entreprise)\" class=\"external-link\" rel=\"nofollow\"> Oracle</a> qui détient et maintient désormais<a href=\"https://fr.wikipedia.org/wiki/Java_(technique)\" class=\"external-link\" rel=\"nofollow\"> Java</a>.</p><p>Une particularité de Java est que les logiciels écrits dans ce langage sont compilés vers une représentation binaire intermédiaire qui peut être exécutée dans une machine virtuelle Java (JVM) en faisant abstraction du<a href=\"https://fr.wikipedia.org/wiki/Syst%C3%A8me_d%27exploitation\" class=\"external-link\" rel=\"nofollow\"> système d'exploitation</a>.</p><p>Le langage Java reprend en grande partie la syntaxe du langage<a href=\"https://fr.wikipedia.org/wiki/C%2B%2B\" class=\"external-link\" rel=\"nofollow\"> C++</a>. Néanmoins, Java a été épuré des concepts les plus subtils du<a href=\"https://fr.wikipedia.org/wiki/C%2B%2B\" class=\"external-link\" rel=\"nofollow\"> C++</a> et à la fois les plus déroutants, tels que les pointeurs et références, ou l’<a href=\"https://fr.wikipedia.org/wiki/H%C3%A9ritage_multiple\" class=\"external-link\" rel=\"nofollow\">héritage multiple</a> contourné par l’implémentation des<a href=\"https://fr.wikipedia.org/wiki/Interface_(programmation_orient%C3%A9e_objet)\" class=\"external-link\" rel=\"nofollow\"> interfaces</a>, et même depuis la version 8, l'arrivée des interfaces fonctionnelles introduit l'héritage multiple (sans la gestion des attributs) avec ses avantages et inconvénients tels que l'héritage en diamant. Les concepteurs ont privilégié l’<a href=\"https://fr.wikipedia.org/wiki/Programmation_orient%C3%A9e_objet\" class=\"external-link\" rel=\"nofollow\">approche orientée objet</a> de sorte qu’en Java, tout est objet à l’exception des<a href=\"https://fr.wikipedia.org/wiki/Type_(informatique)\" class=\"external-link\" rel=\"nofollow\"> types</a> primitifs (nombres entiers, nombres à virgule flottante, etc.) qui ont cependant leurs variantes qui héritent de l'objet Object (Integer, Float, ...). </p><p> </p><h3 id=\"JavaInitial-LesVersions:\">Les Versions:</h3><span class=\"confluence-embedded-file-wrapper image-center-wrapper confluence-embedded-manual-size\"><img class=\"confluence-embedded-image image-center\" width=\"340\" loading=\"lazy\" src=\"https://computhand.atlassian.net/wiki/download/thumbnails/153485313/R8pFhbmF9h0FM7eQHrNqn6AESHgKJpi5SRVzehZE6VPnWqZrGZgqfBmeSMbywvhWnT95leCEY9pVIZM_WCRriPbxQNAd2XyNDoSms_4p8jRS8B0mAqvDSh2WR8vdT0EoT2RbGr_nsLg?version=1&amp;modificationDate=1589917010049&amp;cacheVersion=1&amp;api=v2&amp;width=340&amp;height=533\" data-image-src=\"https://computhand.atlassian.net/wiki/download/attachments/153485313/R8pFhbmF9h0FM7eQHrNqn6AESHgKJpi5SRVzehZE6VPnWqZrGZgqfBmeSMbywvhWnT95leCEY9pVIZM_WCRriPbxQNAd2XyNDoSms_4p8jRS8B0mAqvDSh2WR8vdT0EoT2RbGr_nsLg?version=1&amp;modificationDate=1589917010049&amp;cacheVersion=1&amp;api=v2\" data-height=\"1570\" data-width=\"1000\" data-unresolved-comment-count=\"0\" data-linked-resource-id=\"188284934\" data-linked-resource-version=\"1\" data-linked-resource-type=\"attachment\" data-linked-resource-default-alias=\"R8pFhbmF9h0FM7eQHrNqn6AESHgKJpi5SRVzehZE6VPnWqZrGZgqfBmeSMbywvhWnT95leCEY9pVIZM_WCRriPbxQNAd2XyNDoSms_4p8jRS8B0mAqvDSh2WR8vdT0EoT2RbGr_nsLg\" data-base-url=\"https://computhand.atlassian.net/wiki\" data-linked-resource-content-type=\"image/png\" data-linked-resource-container-id=\"153485313\" data-linked-resource-container-version=\"17\" data-media-id=\"af5dc300-b383-409e-bff8-f29a7148bdf3\" data-media-type=\"file\" srcset=\"https://computhand.atlassian.net/wiki/download/thumbnails/153485313/R8pFhbmF9h0FM7eQHrNqn6AESHgKJpi5SRVzehZE6VPnWqZrGZgqfBmeSMbywvhWnT95leCEY9pVIZM_WCRriPbxQNAd2XyNDoSms_4p8jRS8B0mAqvDSh2WR8vdT0EoT2RbGr_nsLg?version=1&amp;modificationDate=1589917010049&amp;cacheVersion=1&amp;api=v2&amp;width=680&amp;height=1066 2x, https://computhand.atlassian.net/wiki/download/thumbnails/153485313/R8pFhbmF9h0FM7eQHrNqn6AESHgKJpi5SRVzehZE6VPnWqZrGZgqfBmeSMbywvhWnT95leCEY9pVIZM_WCRriPbxQNAd2XyNDoSms_4p8jRS8B0mAqvDSh2WR8vdT0EoT2RbGr_nsLg?version=1&amp;modificationDate=1589917010049&amp;cacheVersion=1&amp;api=v2&amp;width=340&amp;height=533 1x\"></span><span class=\"confluence-embedded-file-wrapper image-center-wrapper confluence-embedded-manual-size\"><img class=\"confluence-embedded-image image-center\" width=\"442\" loading=\"lazy\" src=\"https://computhand.atlassian.net/wiki/download/thumbnails/153485313/FMsM0V-WmY2tAk-3y-4cCf_mSLZGMVZCjIoTzFadMPqpESy-hcjPK2Ng_SF-1-8AmD8-7yGp2uNwkG-hQTPOSaggogj-AYqxlM-Rx_DqE18fUxr-fckgbic3pEd-yFSyrCFRHc39sww?version=1&amp;modificationDate=1589917036004&amp;cacheVersion=1&amp;api=v2&amp;width=442&amp;height=186\" data-image-src=\"https://computhand.atlassian.net/wiki/download/attachments/153485313/FMsM0V-WmY2tAk-3y-4cCf_mSLZGMVZCjIoTzFadMPqpESy-hcjPK2Ng_SF-1-8AmD8-7yGp2uNwkG-hQTPOSaggogj-AYqxlM-Rx_DqE18fUxr-fckgbic3pEd-yFSyrCFRHc39sww?version=1&amp;modificationDate=1589917036004&amp;cacheVersion=1&amp;api=v2\" data-height=\"316\" data-width=\"747\" data-unresolved-comment-count=\"0\" data-linked-resource-id=\"188350467\" data-linked-resource-version=\"1\" data-linked-resource-type=\"attachment\" data-linked-resource-default-alias=\"FMsM0V-WmY2tAk-3y-4cCf_mSLZGMVZCjIoTzFadMPqpESy-hcjPK2Ng_SF-1-8AmD8-7yGp2uNwkG-hQTPOSaggogj-AYqxlM-Rx_DqE18fUxr-fckgbic3pEd-yFSyrCFRHc39sww\" data-base-url=\"https://computhand.atlassian.net/wiki\" data-linked-resource-content-type=\"image/png\" data-linked-resource-container-id=\"153485313\" data-linked-resource-container-version=\"17\" data-media-id=\"9caa2fd3-0cc5-4e1c-9845-b435d3803b5e\" data-media-type=\"file\" srcset=\"https://computhand.atlassian.net/wiki/download/thumbnails/153485313/FMsM0V-WmY2tAk-3y-4cCf_mSLZGMVZCjIoTzFadMPqpESy-hcjPK2Ng_SF-1-8AmD8-7yGp2uNwkG-hQTPOSaggogj-AYqxlM-Rx_DqE18fUxr-fckgbic3pEd-yFSyrCFRHc39sww?version=1&amp;modificationDate=1589917036004&amp;cacheVersion=1&amp;api=v2&amp;width=747&amp;height=316 2x, https://computhand.atlassian.net/wiki/download/thumbnails/153485313/FMsM0V-WmY2tAk-3y-4cCf_mSLZGMVZCjIoTzFadMPqpESy-hcjPK2Ng_SF-1-8AmD8-7yGp2uNwkG-hQTPOSaggogj-AYqxlM-Rx_DqE18fUxr-fckgbic3pEd-yFSyrCFRHc39sww?version=1&amp;modificationDate=1589917036004&amp;cacheVersion=1&amp;api=v2&amp;width=442&amp;height=186 1x\"></span><span class=\"confluence-embedded-file-wrapper image-center-wrapper confluence-embedded-manual-size\"><img class=\"confluence-embedded-image image-center\" width=\"442\" loading=\"lazy\" src=\"https://computhand.atlassian.net/wiki/download/thumbnails/153485313/B_OuFJCNiZ8QZ1uFKecqUejHzxUEgRcs_8WqKrQKwqwNeCqCYCYdqEpywJAn-YIzo5XBBDsCNBb0pvydPXms-1-Dws_0nZV5A-KZMlCTBs1hnCJwFGrobIhsv-GsQNmCBehoz-RDJRk?version=1&amp;modificationDate=1589917065975&amp;cacheVersion=1&amp;api=v2&amp;width=442&amp;height=360\" data-image-src=\"https://computhand.atlassian.net/wiki/download/attachments/153485313/B_OuFJCNiZ8QZ1uFKecqUejHzxUEgRcs_8WqKrQKwqwNeCqCYCYdqEpywJAn-YIzo5XBBDsCNBb0pvydPXms-1-Dws_0nZV5A-KZMlCTBs1hnCJwFGrobIhsv-GsQNmCBehoz-RDJRk?version=1&amp;modificationDate=1589917065975&amp;cacheVersion=1&amp;api=v2\" data-height=\"502\" data-width=\"616\" data-unresolved-comment-count=\"0\" data-linked-resource-id=\"188317701\" data-linked-resource-version=\"1\" data-linked-resource-type=\"attachment\" data-linked-resource-default-alias=\"B_OuFJCNiZ8QZ1uFKecqUejHzxUEgRcs_8WqKrQKwqwNeCqCYCYdqEpywJAn-YIzo5XBBDsCNBb0pvydPXms-1-Dws_0nZV5A-KZMlCTBs1hnCJwFGrobIhsv-GsQNmCBehoz-RDJRk\" data-base-url=\"https://computhand.atlassian.net/wiki\" data-linked-resource-content-type=\"image/png\" data-linked-resource-container-id=\"153485313\" data-linked-resource-container-version=\"17\" data-media-id=\"0875c1dd-c8d4-4eb5-bcaa-7c96bf9b7de5\" data-media-type=\"file\" srcset=\"https://computhand.atlassian.net/wiki/download/thumbnails/153485313/B_OuFJCNiZ8QZ1uFKecqUejHzxUEgRcs_8WqKrQKwqwNeCqCYCYdqEpywJAn-YIzo5XBBDsCNBb0pvydPXms-1-Dws_0nZV5A-KZMlCTBs1hnCJwFGrobIhsv-GsQNmCBehoz-RDJRk?version=1&amp;modificationDate=1589917065975&amp;cacheVersion=1&amp;api=v2&amp;width=616&amp;height=502 2x, https://computhand.atlassian.net/wiki/download/thumbnails/153485313/B_OuFJCNiZ8QZ1uFKecqUejHzxUEgRcs_8WqKrQKwqwNeCqCYCYdqEpywJAn-YIzo5XBBDsCNBb0pvydPXms-1-Dws_0nZV5A-KZMlCTBs1hnCJwFGrobIhsv-GsQNmCBehoz-RDJRk?version=1&amp;modificationDate=1589917065975&amp;cacheVersion=1&amp;api=v2&amp;width=442&amp;height=360 1x\"></span><h3 id=\"JavaInitial-JavaSE\">Java SE</h3><p>Le terme « Java » fait bien évidemment référence à un langage, mais également à une plate-forme : son nom complet est « Java SE » pour <em>Java Standard Edition</em>, et était anciennement raccourci « J2SE ». Celle-ci est constituée de nombreuses bibliothèques, ou API : citons par exemple java.lang, <a href=\"http://java.io\" class=\"external-link\" rel=\"nofollow\">java.io</a>, java.math, java.util, etc. Toutes ces bibliothèques contiennent un nombre conséquent de classes et leurs méthodes utilisables offrant des algorithmes devenus des standards du code. Voir <a href=\"https://jcp.org/\" class=\"external-link\" rel=\"nofollow\"><u>https://jcp.org</u></a> et JSR</p><div class=\"confluence-information-macro confluence-information-macro-note conf-macro output-block\" data-hasbody=\"true\" data-macro-name=\"note\" data-macro-id=\"c248ef52-f03a-473d-a285-8edf2edb6068\"><span class=\"aui-icon aui-icon-small aui-iconfont-warning confluence-information-macro-icon\"> </span><div class=\"confluence-information-macro-body\"><p>NE PAS CONFONDRE avec JavaScript langage interprété côte navigateur internet.</p></div></div><h3 id=\"JavaInitial-Fonctionnement\">Fonctionnement</h3><p>Le Java est un langage de programmation qui s'écrit dans un ou plusieurs fichiers.</p><p>C’est un langage orienté objet dit interprété car lu par un programme pour permettre son exécution (JVM)</p><ul><li><p>Les fichiers <span style=\"color: rgb(191,38,0);\">.java</span> sont compilés (Lus et compris) par un programme que l'on appelle un compilateur.</p></li><li><p>Le compilateur produit un fichier <span style=\"color: rgb(191,38,0);\">.class</span> qui peut être utilisé avec l'interpréteur Java.</p></li><li><p>L'interpréteur Java s'occupe de convertir un programme Java en code compréhensible par la machine qui le lit.</p></li></ul><h2 id=\"JavaInitial-Lesdifférentsmodules\"><strong>Les différents modules</strong></h2><p>Java c'est avant tout,  différents modules:</p><ul><li><p><span style=\"color: rgb(191,38,0);\">javac</span>: Le compilateur <strong>Java</strong>. Il s'occupe de comprendre votre code et prépare une version lisible sur toutes les machines pouvant lire du <strong>Java</strong>.</p></li><li><p><span style=\"color: rgb(191,38,0);\">java</span>: L'interpréteur <strong>Java</strong>. Il s'occupe de transformer le code intermédiaire <strong>Java</strong> en code que la machine peut utiliser.</p></li><li><p><span style=\"color: rgb(191,38,0);\">javadoc</span>: Le générateur de documentation. Il lit le code source et crée une documentation que les développeurs peuvent utiliser pour développer plus rapidement.</p></li></ul><p>Il existe 2 utilitaires pour le Java, un pour l'exécution et l’autre pour la compilation:</p><ul><li><p><span style=\"color: rgb(191,38,0);\">JRE</span>: Le <strong>Java Runtime Environment</strong> est l'interpréteur <strong>Java</strong> qui exécute des programmes sur les machines des utilisateurs.</p></li><li><p><span style=\"color: rgb(191,38,0);\">JDK</span>: Le <strong>Java Development Kit</strong> contient le <span style=\"color: rgb(191,38,0);\">JRE</span> ainsi que les outils de programmation comme <span style=\"color: rgb(191,38,0);\">javac</span> et <span style=\"color: rgb(191,38,0);\">javadoc</span>.</p></li></ul><h2 id=\"JavaInitial-Compilationetéxécutionlignedecommande\"><strong>Compilation et éxécution ligne de commande</strong></h2><p>Vérifiez votre version de java grace aux commandes suivantes:</p><div class=\"code panel pdl conf-macro output-block\" style=\"border-width: 1px;\" data-hasbody=\"true\" data-macro-name=\"code\" data-macro-id=\"c7f42ea2-9233-4cbd-a8fa-f78ba20b3cf3\"><div class=\"codeContent panelContent pdl\">\n<pre class=\"syntaxhighlighter-pre\" data-syntaxhighlighter-params=\"brush: powershell; gutter: false; theme: Confluence\" data-theme=\"Confluence\">// Windows\njava -version\n// Unix (Mac ou Linux)\njava --version</pre>\n</div></div><p>Créez un fichier Exercice1.java</p><div class=\"code panel pdl conf-macro output-block\" style=\"border-width: 1px;\" data-hasbody=\"true\" data-macro-name=\"code\" data-macro-id=\"9c082a33-2099-43ef-8331-d6c7d436e098\"><div class=\"codeContent panelContent pdl\">\n<pre class=\"syntaxhighlighter-pre\" data-syntaxhighlighter-params=\"brush: java; gutter: false; theme: Confluence\" data-theme=\"Confluence\">public class Exercice1 {\n    public static void main (String[] args) {\n        System.out.println(&quot;Bienvenue dans cette formation Java&quot;);\n    }\n}</pre>\n</div></div><h2 id=\"JavaInitial-Utilisationd&#39;unIDE\"><strong>Utilisation d'un IDE</strong></h2><h3 id=\"JavaInitial-Définition\">Définition</h3><p>Un programme en Java contiendra souvent plusieurs fichiers et peut rapidement devenir très difficile à gérer si vous n'utilisez pas l'outil approprié. Plusieurs outils existent pour programmer en Java, en voici quelques exemples:</p><ul><li><p>Eclipse</p></li><li><p>VS.Code</p></li><li><p>IntelliJ</p></li></ul><h2 id=\"JavaInitial-Votrepremierprogramme\">Votre premier programme</h2><p>Ce cours utilisera l'outil Eclipse.</p><p>Vous pouvez le télécharger ici: <a href=\"https://www.eclipse.org/downloads/download.php?file=/oomph/epp/2020-03/R/eclipse-inst-win64.exe\" class=\"external-link\" rel=\"nofollow\"><u>Eclipse IDE 2020-03</u></a></p><p>Creation d’un projet Java dans Eclipse:</p><span class=\"confluence-embedded-file-wrapper image-center-wrapper\"><img class=\"confluence-embedded-image image-center\" loading=\"lazy\" src=\"https://computhand.atlassian.net/wiki/download/attachments/153485313/image-20200520-184152.png?version=1&amp;modificationDate=1590000114833&amp;cacheVersion=1&amp;api=v2\" data-image-src=\"https://computhand.atlassian.net/wiki/download/attachments/153485313/image-20200520-184152.png?version=1&amp;modificationDate=1590000114833&amp;cacheVersion=1&amp;api=v2\" data-height=\"477\" data-width=\"1289\" data-unresolved-comment-count=\"0\" data-linked-resource-id=\"190513161\" data-linked-resource-version=\"1\" data-linked-resource-type=\"attachment\" data-linked-resource-default-alias=\"image-20200520-184152.png\" data-base-url=\"https://computhand.atlassian.net/wiki\" data-linked-resource-content-type=\"image/png\" data-linked-resource-container-id=\"153485313\" data-linked-resource-container-version=\"17\" data-media-id=\"a57643d8-2f10-4753-a447-1bb6afd5f0ac\" data-media-type=\"file\"></span><p>Creation d’une classe d’éxécution:</p><span class=\"confluence-embedded-file-wrapper image-center-wrapper\"><img class=\"confluence-embedded-image image-center\" loading=\"lazy\" src=\"https://computhand.atlassian.net/wiki/download/attachments/153485313/image-20200520-184307.png?version=1&amp;modificationDate=1590000189494&amp;cacheVersion=1&amp;api=v2\" data-image-src=\"https://computhand.atlassian.net/wiki/download/attachments/153485313/image-20200520-184307.png?version=1&amp;modificationDate=1590000189494&amp;cacheVersion=1&amp;api=v2\" data-height=\"484\" data-width=\"1255\" data-unresolved-comment-count=\"0\" data-linked-resource-id=\"188383264\" data-linked-resource-version=\"1\" data-linked-resource-type=\"attachment\" data-linked-resource-default-alias=\"image-20200520-184307.png\" data-base-url=\"https://computhand.atlassian.net/wiki\" data-linked-resource-content-type=\"image/png\" data-linked-resource-container-id=\"153485313\" data-linked-resource-container-version=\"17\" data-media-id=\"26f38e9e-e310-4401-8c8f-8fcb5a36bb7b\" data-media-type=\"file\"></span><h3 id=\"JavaInitial-LaClasseMain\">La Classe Main</h3><p>Tout programme doit avoir un point d'entrée. Le point d'entrée est l'endroit dans le programme où tout commence. Ce point d'entrée est une méthode ou une fonction.</p><p>Cette méthode à une signature précise qui doit être respectée:</p><p /><div class=\"code panel pdl conf-macro output-block\" style=\"border-width: 1px;\" data-hasbody=\"true\" data-macro-name=\"code\" data-macro-id=\"ebbc20e2-73d8-4891-b319-17d4e9aea76d\"><div class=\"codeContent panelContent pdl\">\n<pre class=\"syntaxhighlighter-pre\" data-syntaxhighlighter-params=\"brush: java; gutter: false; theme: Confluence\" data-theme=\"Confluence\">public static void main (String[] args) {\n  //Some implementation\n}</pre>\n</div></div><p>Ceci étant dit, nous verrons la majorité des points énumérés ici plus loin dans la formation. La méthode:</p><ol><li><p>doit être publique,</p></li><li><p>doit être statique,</p></li><li><p>ne doit rien retourner comme information</p></li><li><p>doit s'apeller <span style=\"color: rgb(191,38,0);\">main</span></p></li><li><p>doit accepter un argument de type <span style=\"color: rgb(191,38,0);\">String[]</span> qui s'appelle <span style=\"color: rgb(191,38,0);\">args</span></p></li></ol><h1 id=\"JavaInitial-SyntaxedeprogrammationJava\"><strong>Syntaxe de programmation Java</strong></h1><h2 id=\"JavaInitial-Syntaxedulangage\"><strong>Syntaxe du langage</strong></h2><h3 id=\"JavaInitial-Définition.1\">Définition</h3><p>Tout langage de programmation utilisera une syntaxe, c'est à dire une série de règles, utilisée pour comprendre vos intentions. La syntaxe et les règles changeront selon le type de langage. Aujourd'hui, nous parlons de Java. Il est important de comprendre que la programmation est un art mais que le langage utilisé pour programmer n'est pas un art. Il est réglementé et très strict!</p><p>Il existe différents langages de programmation mais la plupart dérivent de 2 syntaxes majeures:</p><ol><li><p>La syntaxe C/C++ (Comme Java)</p></li><li><p>La syntaxe Basic</p></li></ol><p>À moins d'écrire une chaîne de texte, le langage Java se résume à:</p><ul><li><p>Des espaces, lettres, chiffres et barres de soulignement</p></li><li><p>Et plusieurs caractères (ou suites de caractères) réservés que l'on nomme opérateurs</p></li></ul><h3 id=\"JavaInitial-ÉlémentsclefsdelasyntaxeJava\">Éléments clefs de la syntaxe Java</h3><p><br/>Par exemple, des opérateurs très connus de tous sont: <span style=\"color: rgb(191,38,0);\">=</span>,<span style=\"color: rgb(191,38,0);\">+</span>, <span style=\"color: rgb(191,38,0);\">-</span>, <span style=\"color: rgb(191,38,0);\">/</span>, <span style=\"color: rgb(191,38,0);\">*</span>, les <span style=\"color: rgb(191,38,0);\">( )</span> pour les principaux. Lorsque vous tapez du code Java, le plus important est de se rappeler qu'un espace est un séparateur clef, il délimite les mots qui sont utilisés dans la compréhension de vos intentions. Il existe d'autres caractères importants qui déterminent des opérations à lancer mais généralement, vos instructions et mots clefs seront séparés par des espaces. Reprenons le point d'entrée comme exemple:</p><div class=\"code panel pdl conf-macro output-block\" style=\"border-width: 1px;\" data-hasbody=\"true\" data-macro-name=\"code\" data-macro-id=\"18cdd203-8236-49d3-bca2-7e04562da725\"><div class=\"codeContent panelContent pdl\">\n<pre class=\"syntaxhighlighter-pre\" data-syntaxhighlighter-params=\"brush: java; gutter: false; theme: Confluence\" data-theme=\"Confluence\">public static void main (String[] args) {\n  //Some implementation\n}</pre>\n</div></div><p>Chaque mot clef ou token important ici est séparé par des espaces (ou presque): <span style=\"color: rgb(191,38,0);\">public</span>, <span style=\"color: rgb(191,38,0);\">static</span>, <span style=\"color: rgb(191,38,0);\">void</span>, <span style=\"color: rgb(191,38,0);\">main</span>,<span style=\"color: rgb(255,255,255);\"> </span><span style=\"color: rgb(191,38,0);\">(</span>,<span style=\"color: rgb(255,255,255);\"> </span><span style=\"color: rgb(191,38,0);\">String</span>, <span style=\"color: rgb(191,38,0);\">[</span>, <span style=\"color: rgb(191,38,0);\">]</span>, <span style=\"color: rgb(191,38,0);\">args</span>, <span style=\"color: rgb(191,38,0);\">)</span>, <span style=\"color: rgb(191,38,0);\">{</span><span style=\"color: rgb(255,255,255);\"> </span>et<span style=\"color: rgb(255,255,255);\"> </span><span style=\"color: rgb(191,38,0);\">}</span>.</p><p>Ici, certains éléments sont aussi considérés comme des mots clefs ou token car ils sont eux-même des séparateurs tels que: <span style=\"color: rgb(191,38,0);\">(</span>,<span style=\"color: rgb(255,255,255);\"> </span><span style=\"color: rgb(191,38,0);\">[</span>, <span style=\"color: rgb(191,38,0);\">]</span>, <span style=\"color: rgb(191,38,0);\">)</span>, <span style=\"color: rgb(191,38,0);\">{ </span>et<span style=\"color: rgb(255,255,255);\"> </span><span style=\"color: rgb(191,38,0);\">}</span>.</p><h3 id=\"JavaInitial-ConventiondeNommage\">Convention de Nommage</h3><p>Les programmes respectant les conventions de nommage sont plus lisible et facile à comprendre. Ils définissent plus clairement ses éléments, par exemple pour savoir si c’est une constante un package ou une classe dont le nom est explicite. Tout ces normes contribuent à une meilleur compréhension du code.</p><p> </p><div class=\"table-wrap\"><table data-layout=\"default\" class=\"confluenceTable\"><colgroup><col style=\"width: 226.67px;\"/><col style=\"width: 226.67px;\"/><col style=\"width: 226.67px;\"/></colgroup><tbody><tr><td data-highlight-colour=\"#e0ddda\" class=\"confluenceTd\"><p><strong>Type d’identifiant</strong></p></td><td data-highlight-colour=\"#e0ddda\" class=\"confluenceTd\"><p><strong>Règles de nommage</strong></p></td><td data-highlight-colour=\"#e0ddda\" class=\"confluenceTd\"><p><strong>Exemples</strong></p></td></tr><tr><td data-highlight-colour=\"#ffffff\" class=\"confluenceTd\"><p /><p /><p /><p /><p>Packages</p></td><td data-highlight-colour=\"#ffffff\" class=\"confluenceTd\"><p>Le préfixe d'un nom de package unique est toujours écrit en lettres ASCII tout en minuscules et doit être l'un des noms de domaine de premier niveau, actuellement com, edu, gov, mil, net, org ou l'un des codes anglais à deux lettres identifiant les pays comme spécifié dans la norme ISO 3166, 1981.</p><p>Les composants suivants du nom du package varient en fonction des propres conventions de dénomination internes d'une organisation. De telles conventions peuvent spécifier que certains composants de nom de répertoire sont des noms de division, de service, de projet, de machine ou de connexion.</p></td><td data-highlight-colour=\"#ffffff\" class=\"confluenceTd\"><p /><p /><p /><p><span style=\"color: rgb(191,38,0);\">com.sun.eng</span></p><p><span style=\"color: rgb(191,38,0);\">com.apple.quicktime.v2</span></p><p><span style=\"color: rgb(191,38,0);\">edu.cmu.cs.bovik.cheese</span></p></td></tr><tr><td data-highlight-colour=\"#ffffff\" class=\"confluenceTd\"><p /><p /><p>Classes</p></td><td data-highlight-colour=\"#ffffff\" class=\"confluenceTd\"><p>Les noms de classe doivent être des noms, en cas de mélange avec la première lettre de chaque mot interne en majuscule. Essayez de garder vos noms de classe simples et descriptifs. Utilisez des mots entiers - évitez les acronymes et les abréviations (sauf si l'abréviation est beaucoup plus largement utilisée que la forme longue, comme URL ou HTML).</p></td><td data-highlight-colour=\"#ffffff\" class=\"confluenceTd\"><p /><p><span style=\"color: rgb(191,38,0);\">class Raster;</span></p><p><span style=\"color: rgb(191,38,0);\">class ImageSprite;</span></p><p><br/></p></td></tr><tr><td data-highlight-colour=\"#ffffff\" class=\"confluenceTd\"><p /><p /><p>Interfaces</p></td><td data-highlight-colour=\"#ffffff\" class=\"confluenceTd\"><p>Le nom des interfaces doit être avoir leur première lettre en majuscule en respectant la convention CamelCase un I majuscule peut être mis en premier lettre pour indiquer que le type de la classe est une interface</p></td><td data-highlight-colour=\"#ffffff\" class=\"confluenceTd\"><p /><p><span style=\"color: rgb(191,38,0);\">interface RasterDelegate;</span></p><p><span style=\"color: rgb(191,38,0);\">interface IStoring;</span></p><p><br/></p></td></tr><tr><td data-highlight-colour=\"#ffffff\" class=\"confluenceTd\"><p /><p>Méthodes</p></td><td data-highlight-colour=\"#ffffff\" class=\"confluenceTd\"><p>Les méthodes doivent être des verbes, en cas de mélange avec la première lettre en minuscule, avec la première lettre de chaque mot interne en majuscule (CamelCase).</p></td><td data-highlight-colour=\"#ffffff\" class=\"confluenceTd\"><p><span style=\"color: rgb(191,38,0);\">run();</span></p><p><span style=\"color: rgb(191,38,0);\">runFast();</span></p><p><span style=\"color: rgb(191,38,0);\">getBackground();</span></p></td></tr><tr><td data-highlight-colour=\"#ffffff\" class=\"confluenceTd\"><p /><p /><p /><p /><p /><p>Variables</p></td><td data-highlight-colour=\"#ffffff\" class=\"confluenceTd\"><p>À l'exception des variables, toutes les instance, de classe et de classe de constantes sont en casse mixte avec une première lettre minuscule. Les mots internes commencent par des majuscules. Les noms de variable ne doivent pas commencer par le caractère de soulignement <span style=\"color: rgb(191,38,0);\">_</span> ou le signe <span style=\"color: rgb(191,38,0);\">$</span>, même si les deux sont autorisés.</p><p>Les noms de variables doivent être courts mais significatifs. Le choix d'un nom de variable doit être mnémonique, c'est-à-dire conçu pour indiquer à l'observateur occasionnel l'intention de son utilisation. Les noms de variable à un caractère doivent être évités, sauf pour les variables temporaires &quot;jetables&quot;. Les noms communs pour les variables temporaires sont <span style=\"color: rgb(191,38,0);\">i</span>, <span style=\"color: rgb(191,38,0);\">j</span>, <span style=\"color: rgb(191,38,0);\">k</span>, <span style=\"color: rgb(191,38,0);\">m</span> et <span style=\"color: rgb(191,38,0);\">n</span> pour les entiers; <span style=\"color: rgb(191,38,0);\">c</span>, <span style=\"color: rgb(191,38,0);\">d</span> et <span style=\"color: rgb(191,38,0);\">e</span> pour les caractères.</p></td><td data-highlight-colour=\"#ffffff\" class=\"confluenceTd\"><p /><p /><p /><p /><p /><p><span style=\"color: rgb(191,38,0);\">int             i;</span></p><p><span style=\"color: rgb(191,38,0);\">char            c;</span><br/></p><p><span style=\"color: rgb(191,38,0);\">float           myWidth;</span></p><p><br/></p></td></tr><tr><td data-highlight-colour=\"#ffffff\" class=\"confluenceTd\"><p /><p>Constantes</p></td><td data-highlight-colour=\"#ffffff\" class=\"confluenceTd\"><p>Les noms des variables déclarées constantes de classe et des constantes ANSI doivent être tous en majuscules avec des mots séparés par des traits de soulignement (&quot;_&quot;). (Les constantes ANSI doivent être évitées, pour faciliter le débogage.)</p></td><td data-highlight-colour=\"#ffffff\" class=\"confluenceTd\"><p /><p><span style=\"color: rgb(191,38,0);\">static final int MIN_WIDTH = 4;</span></p><p><span style=\"color: rgb(191,38,0);\">static final int MAX_WIDTH = 999;</span></p><p><span style=\"color: rgb(191,38,0);\">static final int GET_THE_CPU = 1;</span></p></td></tr></tbody></table></div><p><br/></p><h2 id=\"JavaInitial-Variabledetypeprimitif\"><strong>Variable de type primitif</strong></h2><h3 id=\"JavaInitial-Définition.2\">Définition</h3><p>Les types primitifs en Java sont : <span style=\"color: rgb(191,38,0);\">byte</span><em>, </em><span style=\"color: rgb(191,38,0);\">short</span><em>, </em><span style=\"color: rgb(191,38,0);\">int</span><em>, </em><span style=\"color: rgb(191,38,0);\">long</span> pour les types entiers, <span style=\"color: rgb(191,38,0);\">float</span><em>, </em><span style=\"color: rgb(191,38,0);\">double</span> pour les « réels », un seul type caractère qui est <span style=\"color: rgb(191,38,0);\">char</span>, et un type booléen à savoir <span style=\"color: rgb(191,38,0);\">boolean</span>. Notez le fait que tous ces types ont leur première lettre minuscule, ce qui indique qu’il ne s’agit pas de classe conformément aux conventions de nommage en Java.</p><h3 id=\"JavaInitial-Valeurs\">Valeurs</h3><p> </p><div class=\"table-wrap\"><table data-layout=\"default\" class=\"confluenceTable\"><colgroup><col style=\"width: 340.0px;\"/><col style=\"width: 340.0px;\"/></colgroup><tbody><tr><td class=\"confluenceTd\"><p><strong>Type</strong></p></td><td class=\"confluenceTd\"><p><strong>Description</strong></p></td></tr><tr><td data-highlight-colour=\"#f3f6f6\" class=\"confluenceTd\"><p><span style=\"color: rgb(191,38,0);\">byte</span></p></td><td data-highlight-colour=\"#f3f6f6\" class=\"confluenceTd\"><p>Entier très court allant de -128 à +127</p></td></tr><tr><td class=\"confluenceTd\"><p><span style=\"color: rgb(191,38,0);\">short</span></p></td><td class=\"confluenceTd\"><p>Entier court allant de -32768 à +32767</p></td></tr><tr><td data-highlight-colour=\"#f3f6f6\" class=\"confluenceTd\"><p><span style=\"color: rgb(191,38,0);\">int</span></p></td><td data-highlight-colour=\"#f3f6f6\" class=\"confluenceTd\"><p>Entier allant de -2 147 483 648 à +2 147 483 647</p></td></tr><tr><td class=\"confluenceTd\"><p><span style=\"color: rgb(191,38,0);\">long</span></p></td><td class=\"confluenceTd\"><p>Entier long allant de -263 à +263 -1</p></td></tr><tr><td data-highlight-colour=\"#f3f6f6\" class=\"confluenceTd\"><p><span style=\"color: rgb(191,38,0);\">float</span></p></td><td data-highlight-colour=\"#f3f6f6\" class=\"confluenceTd\"><p>Nombre réel allant de -1.4 * 10-45 à +3.4 * 1038</p></td></tr><tr><td class=\"confluenceTd\"><p><span style=\"color: rgb(191,38,0);\">double</span></p></td><td class=\"confluenceTd\"><p>Nombre réel double précision allant de 4.9 * 10-324 à +1.7 * 10308</p></td></tr><tr><td data-highlight-colour=\"#f3f6f6\" class=\"confluenceTd\"><p><span style=\"color: rgb(191,38,0);\">char</span></p></td><td data-highlight-colour=\"#f3f6f6\" class=\"confluenceTd\"><p>Caractère unicode (65536 caractères possibles)</p></td></tr><tr><td class=\"confluenceTd\"><p><span style=\"color: rgb(191,38,0);\">boolean</span></p></td><td class=\"confluenceTd\"><p>Contient une valeur booléenne soit <span style=\"color: rgb(191,38,0);\">true </span>ou <span style=\"color: rgb(191,38,0);\">false</span></p></td></tr></tbody></table></div><p /><div class=\"confluence-information-macro confluence-information-macro-information conf-macro output-block\" data-hasbody=\"true\" data-macro-name=\"info\" data-macro-id=\"1104bf4f-86eb-4736-9787-1101f925c7f2\"><span class=\"aui-icon aui-icon-small aui-iconfont-info confluence-information-macro-icon\"> </span><div class=\"confluence-information-macro-body\"><p>L'autoboxing permet de transformer automatiquement une variable de type primitif en un objet du type du wrapper correspondant.</p></div></div><h2 id=\"JavaInitial-Commenteretdocumenterducode\"><strong>Commenter et documenter du code</strong></h2><h3 id=\"JavaInitial-Définition.3\">Définition</h3><p>Tout programmeur se doit de mettre des commentaires dans son code. Commenter du code est essentiel. Cela permet une compréhension de la logique et des décisions techniques du code qui a été écrit. Même si vous apprendrez à être plus pertinent dans leur rédaction, il vaut mieux en mettre plus que moins.</p><p>Vous pouvez faire autant de commentaires que vous le souhaitez. Les commentaires ne feront pas partie du code source final compilé. Si vous décompilez un fichier .class, vous ne retrouverez plus ces commentaires.</p><h3 id=\"JavaInitial-Syntaxe\">Syntaxe</h3><h4 id=\"JavaInitial-Commentairessimples\">Commentaires simples</h4><p>Pour ajouter un commentaire dans votre code, vous devez le préfixer avec //. Vous pouvez mettre un commentaire simple n'importe où dans une ligne de cod<span style=\"color: rgb(255,255,255);\">e:</span><br/></p><div class=\"code panel pdl conf-macro output-block\" style=\"border-width: 1px;\" data-hasbody=\"true\" data-macro-name=\"code\" data-macro-id=\"5db8ebe0-9bed-4e3a-b9cf-3ac1d41f5653\"><div class=\"codeContent panelContent pdl\">\n<pre class=\"syntaxhighlighter-pre\" data-syntaxhighlighter-params=\"brush: java; gutter: false; theme: Confluence\" data-theme=\"Confluence\">// Voici un commentaire sur une ligne\nlong maVar = 123; // Voici un commentaire de fin de ligne</pre>\n</div></div><h4 id=\"JavaInitial-Commentairesmulti-lignes\">Commentaires multi-lignes</h4><p>Pour ajouter un commentaire multiligne dans votre code, vous devez l'entourer de <span style=\"color: rgb(191,38,0);\">/**</span> et <span style=\"color: rgb(191,38,0);\">*/</span>. Ces commentaires ne sont pas utilisés en fin de ligne, seulement pour faire un bloc. En général, chaque ligne aura un <span style=\"color: rgb(191,38,0);\">*</span> en avant et vous utiliserez souvent plusieurs <span style=\"color: rgb(191,38,0);\">*</span> pour encadrer le commentaire:</p><p /><div class=\"code panel pdl conf-macro output-block\" style=\"border-width: 1px;\" data-hasbody=\"true\" data-macro-name=\"code\" data-macro-id=\"06d04767-1470-400d-a47d-924de42bf928\"><div class=\"codeContent panelContent pdl\">\n<pre class=\"syntaxhighlighter-pre\" data-syntaxhighlighter-params=\"brush: java; gutter: false; theme: Confluence\" data-theme=\"Confluence\">/**\n * Commentaire multi-ligne\n * plus simple qui explique ce que vous\n * essayez de faire!\n */</pre>\n</div></div><p /><div class=\"code panel pdl conf-macro output-block\" style=\"border-width: 1px;\" data-hasbody=\"true\" data-macro-name=\"code\" data-macro-id=\"ae9036aa-c582-4f81-a7a9-1f8eee097beb\"><div class=\"codeContent panelContent pdl\">\n<pre class=\"syntaxhighlighter-pre\" data-syntaxhighlighter-params=\"brush: java; gutter: false; theme: Confluence\" data-theme=\"Confluence\">/***********************************************************\n * Commentaire multi-ligne\n * plus simple qui explique ce que vous\n * essayez de faire!\n**********************************************************/</pre>\n</div></div><h4 id=\"JavaInitial-JavaDoc\">JavaDoc</h4><p>Un commentaire de type JavaDoc est un commentaire complexe, descriptif qui contient des méta-données que les outils de programmation peuvent utiliser pour donner de l'aide au programmeur. Cette aide peut être donnée sous forme de documentation additionnelle ou au travers de l'éditeur de code pour faire des suggestions intelligentes. Voici un exemple:</p><div class=\"code panel pdl conf-macro output-block\" style=\"border-width: 1px;\" data-hasbody=\"true\" data-macro-name=\"code\" data-macro-id=\"c486bd27-60de-40c8-a7d5-0d55842d462c\"><div class=\"codeContent panelContent pdl\">\n<pre class=\"syntaxhighlighter-pre\" data-syntaxhighlighter-params=\"brush: java; gutter: false; theme: Confluence\" data-theme=\"Confluence\">/**\n * Class {@code Object} is the root of the class hierarchy.\n * Every class has {@code Object} as a superclass. All objects,\n * including arrays, implement the methods of this class.\n *\n * @author  unascribed\n * @see     java.lang.Class\n * @since   JDK1.0\n */\npublic class Object {...}</pre>\n</div></div><p>Ceci aidera le compilateur et l'éditeur de code à vous suggérer de meilleures solutions pour votre programme. En général, vous mettrez ce genre de commentaire sur les fonctions d'une classe.</p><h2 id=\"JavaInitial-Lesconditionsdanslecode:if/else,….\"><strong>Les conditions dans le code: if/else,….</strong></h2><h3 id=\"JavaInitial-ifelse\">if else</h3><div class=\"code panel pdl conf-macro output-block\" style=\"border-width: 1px;\" data-hasbody=\"true\" data-macro-name=\"code\" data-macro-id=\"5a6cb14f-1848-4e04-993c-0082e5db7203\"><div class=\"codeContent panelContent pdl\">\n<pre class=\"syntaxhighlighter-pre\" data-syntaxhighlighter-params=\"brush: java; gutter: false; theme: Confluence\" data-theme=\"Confluence\">int i = 0;\nif (i &lt; 0)\n{\n  System.out.println(&quot;Ce nombre est négatif !&quot;);\n} \nelse\n{\n  if(i == 0)\n    System.out.println(&quot;Ce nombre est nul !&quot;);\n \n  else\n    System.out.println(&quot;Ce nombre est positif !&quot;);\n}</pre>\n</div></div><p /><h3 id=\"JavaInitial-switchcase\">switch case</h3><div class=\"code panel pdl conf-macro output-block\" style=\"border-width: 1px;\" data-hasbody=\"true\" data-macro-name=\"code\" data-macro-id=\"eb98d22d-42bd-497c-85bb-43eb791ef39e\"><div class=\"codeContent panelContent pdl\">\n<pre class=\"syntaxhighlighter-pre\" data-syntaxhighlighter-params=\"brush: java; gutter: false; theme: Confluence\" data-theme=\"Confluence\">switch (/*Variable*/)\n{\n  case /*Argument*/:\n    /*Action*/;\n    break;        \n  default:\n    /*Action*/;             \n}\n</pre>\n</div></div><h2 id=\"JavaInitial-Opérateursdecomparaisonetdelogique\"><strong>Opérateurs de comparaison et de logique</strong></h2><p><span style=\"color: rgb(191,38,0);\">==</span> : permet de tester l'égalité.</p><p><span style=\"color: rgb(191,38,0);\">!=</span> : permet de tester l’inégalité.</p><p><span style=\"color: rgb(191,38,0);\">&lt;</span> : strictement inférieur.</p><p><span style=\"color: rgb(191,38,0);\">&lt;=</span> : inférieur ou égal.</p><p><span style=\"color: rgb(191,38,0);\">&gt;</span> : strictement supérieur.</p><p><span style=\"color: rgb(191,38,0);\">&gt;=</span> : supérieur ou égal.</p><p><span style=\"color: rgb(191,38,0);\">&amp;&amp;</span> : l'opérateur ET. Il permet de préciser une condition</p><p><span style=\"color: rgb(191,38,0);\">||</span> : le OU. Même combat que le précédent.</p><p><span style=\"color: rgb(191,38,0);\">?:</span> : l'opérateur ternaire. Simplification de l'écriture lors d’une affectation </p><div class=\"code panel pdl conf-macro output-block\" style=\"border-width: 1px;\" data-hasbody=\"true\" data-macro-name=\"code\" data-macro-id=\"cb9759d4-2154-4311-9b38-e332b38b3439\"><div class=\"codeContent panelContent pdl\">\n<pre class=\"syntaxhighlighter-pre\" data-syntaxhighlighter-params=\"brush: java; gutter: false; theme: Confluence\" data-theme=\"Confluence\">int max = (x &lt; y) ? y : x ;</pre>\n</div></div><h2 id=\"JavaInitial-Lestableaux\"><strong>Les tableaux</strong></h2><p>Les langages de programmation permettent de définir des tableaux pour stocker dans une variable plusieurs valeurs. Pour récupérer l’une de ces valeurs, on utilisera un indice.<br/>Ces tableaux peuvent être à une ou plusieurs dimensions.</p><p>A une dimension :</p><div class=\"code panel pdl conf-macro output-block\" style=\"border-width: 1px;\" data-hasbody=\"true\" data-macro-name=\"code\" data-macro-id=\"5be39ceb-2989-469e-9813-871ebfb29b28\"><div class=\"codeContent panelContent pdl\">\n<pre class=\"syntaxhighlighter-pre\" data-syntaxhighlighter-params=\"brush: java; gutter: false; theme: Confluence\" data-theme=\"Confluence\">&lt;type du tableau&gt; &lt;nom du tableau&gt; [] = { &lt;contenu du tableau&gt;};</pre>\n</div></div><p>A plusieurs dimensions:</p><p>une fois la notion de tableau assimilé, il faut comprendre qu’un tableau peut lui-même contenir un tableau.</p><p>Chaque tableau contenu est une nouvelle sous dimension.</p><div class=\"code panel pdl conf-macro output-block\" style=\"border-width: 1px;\" data-hasbody=\"true\" data-macro-name=\"code\" data-macro-id=\"ef94176e-546c-4ed6-a915-5e578922e408\"><div class=\"codeContent panelContent pdl\">\n<pre class=\"syntaxhighlighter-pre\" data-syntaxhighlighter-params=\"brush: java; gutter: false; theme: Confluence\" data-theme=\"Confluence\">&lt;type du tableau&gt; &lt;nom du tableau&gt; [][]... = {{ &lt;contenu du tableau&gt;},...};</pre>\n</div></div><span class=\"confluence-embedded-file-wrapper image-center-wrapper\"><img class=\"confluence-embedded-image image-center\" loading=\"lazy\" src=\"https://computhand.atlassian.net/wiki/download/attachments/153485313/J-cHCGabuQFcEFc6y3XiYLpEX2nSCgrLhJPJ1C4_EXUZJgADq3KOQFyusvTlUbHLDWFSzHYcJ6-qgk5C6X6L-vW7GZURLTrl0yfxEGV42Nsg886aMG_8Qn7GEDqTTo-7CbeecZVYmqg?version=1&amp;modificationDate=1590029574417&amp;cacheVersion=1&amp;api=v2\" data-image-src=\"https://computhand.atlassian.net/wiki/download/attachments/153485313/J-cHCGabuQFcEFc6y3XiYLpEX2nSCgrLhJPJ1C4_EXUZJgADq3KOQFyusvTlUbHLDWFSzHYcJ6-qgk5C6X6L-vW7GZURLTrl0yfxEGV42Nsg886aMG_8Qn7GEDqTTo-7CbeecZVYmqg?version=1&amp;modificationDate=1590029574417&amp;cacheVersion=1&amp;api=v2\" data-height=\"144\" data-width=\"442\" data-unresolved-comment-count=\"0\" data-linked-resource-id=\"191660065\" data-linked-resource-version=\"1\" data-linked-resource-type=\"attachment\" data-linked-resource-default-alias=\"J-cHCGabuQFcEFc6y3XiYLpEX2nSCgrLhJPJ1C4_EXUZJgADq3KOQFyusvTlUbHLDWFSzHYcJ6-qgk5C6X6L-vW7GZURLTrl0yfxEGV42Nsg886aMG_8Qn7GEDqTTo-7CbeecZVYmqg\" data-base-url=\"https://computhand.atlassian.net/wiki\" data-linked-resource-content-type=\"image/png\" data-linked-resource-container-id=\"153485313\" data-linked-resource-container-version=\"17\" data-media-id=\"448034e3-80d1-4f57-b35c-30775222e470\" data-media-type=\"file\"></span><h2 id=\"JavaInitial-Lesboucles\"><strong>Les boucles</strong></h2><h4 id=\"JavaInitial-Définition.4\">Définition</h4><p>Dans tous les langages de programmation, les boucles sont utilisées pour exécuter un ensemble d’instructions plusieurs fois jusqu’à ce qu’une condition particulière soit satisfaite.</p><span class=\"confluence-embedded-file-wrapper image-center-wrapper\"><img class=\"confluence-embedded-image image-center\" loading=\"lazy\" src=\"https://computhand.atlassian.net/wiki/download/attachments/153485313/ysviQ6qQAmOQdF1QfXft-UxRknwdMraeP7wNtOMPHhMGG102lP2hhUpNM0BPVUNbbeM0KUwfOaDPCRuL8Rtz9W3BGjOSkMC1qB_xaLuZJ3xau68JjPGRinZ5B1n7ooxSx5_FfoIWkqY?version=1&amp;modificationDate=1590029796079&amp;cacheVersion=1&amp;api=v2\" data-image-src=\"https://computhand.atlassian.net/wiki/download/attachments/153485313/ysviQ6qQAmOQdF1QfXft-UxRknwdMraeP7wNtOMPHhMGG102lP2hhUpNM0BPVUNbbeM0KUwfOaDPCRuL8Rtz9W3BGjOSkMC1qB_xaLuZJ3xau68JjPGRinZ5B1n7ooxSx5_FfoIWkqY?version=1&amp;modificationDate=1590029796079&amp;cacheVersion=1&amp;api=v2\" data-height=\"334\" data-width=\"264\" data-unresolved-comment-count=\"0\" data-linked-resource-id=\"191594525\" data-linked-resource-version=\"1\" data-linked-resource-type=\"attachment\" data-linked-resource-default-alias=\"ysviQ6qQAmOQdF1QfXft-UxRknwdMraeP7wNtOMPHhMGG102lP2hhUpNM0BPVUNbbeM0KUwfOaDPCRuL8Rtz9W3BGjOSkMC1qB_xaLuZJ3xau68JjPGRinZ5B1n7ooxSx5_FfoIWkqY\" data-base-url=\"https://computhand.atlassian.net/wiki\" data-linked-resource-content-type=\"image/png\" data-linked-resource-container-id=\"153485313\" data-linked-resource-container-version=\"17\" data-media-id=\"249677af-de17-4d23-821e-1cc43ec50103\" data-media-type=\"file\"></span><h4 id=\"JavaInitial-Lestypesdeboucles\">Les types de boucles</h4><p><strong>La boucle while:</strong></p><p>Répète une instruction ou un groupe d’instructions jusqu’à ce qu’une condition donnée soit vraie. Il teste la condition avant d’exécuter le corps de la boucle.</p><p><strong>La boucle for:</strong></p><p>Exécute une séquence d’instructions plusieurs fois avec un code abrégé.</p><p><strong>La boucle do…while:</strong></p><p>Fonctionnement identique à la boucle while, sauf qu’elle teste la condition à la fin du corps de la boucle.</p><p><strong>Les boucles imbriquées:</strong></p><p>Vous pouvez utiliser une ou plusieurs boucles à l’intérieur d’une autre boucle while, for ou do..wh<span style=\"color: rgb(255,255,255);\">ile</span></p><h2 id=\"JavaInitial-Méthodedeclasse\"><strong>Méthode de classe</strong></h2><h4 id=\"JavaInitial-Introduction\">Introduction</h4><p>Les instructions et conditions sont souvent répétées. Cela nécessite de réécrire du code ce qui peut être fastidieux et ajouter potentiellement des erreurs du fait d’une mauvaise recopie des standards de déclaration que nous venons de voir.</p><p>Nous verrons dans un premier temps une méthode de type <span style=\"color: rgb(191,38,0);\">static </span>que l’on peut appeler de la méthode <span style=\"color: rgb(191,38,0);\">main</span>. Puis en approfondissant la notion d’objet qui est la force du langage Java nous verrons les différents types de méthodes que l’on peut déclarer.</p><h4 id=\"JavaInitial-Déclaration\">Déclaration</h4><ul><li><p>Portée: définit la visibilité d’une méthode *</p></li><li><p>Type de retour: si la méthode retourne une valeur on spécifie son type (optionnel)</p></li><li><p>Nom de méthode: définition de la méthode en respectant les règles et conventions de nommage du Java</p></li><li><p>La méthode peut avoir ou non un argument si oui il se définit comme suit:</p><ul><li><p>Type d’argument: type de l'élément passé à la méthode</p></li><li><p>Nom de variable: nom pour pouvoir utiliser la variable au sein de la méthode, défini en respectant les règles et conventions de nommage du Java</p></li></ul></li><li><p>Variable locale: variable définie au sein de la méthode avec une portée locale *</p></li></ul><span class=\"confluence-embedded-file-wrapper image-center-wrapper\"><img class=\"confluence-embedded-image image-center\" loading=\"lazy\" src=\"https://computhand.atlassian.net/wiki/download/attachments/153485313/JCtVmzH8Hz_Pkuursye1VG3V1ZgpJ3RD-mcc8O-xIvJqLzSdhwhtBur_S9FziQzCpaCrHLqkhdHeGYUYS_zStVrzUK5Ly5eJTB_g3_J-qofKTbxEu-AF1bA-rlGKv3e2Aih60HosOU0?version=1&amp;modificationDate=1590030061501&amp;cacheVersion=1&amp;api=v2\" data-image-src=\"https://computhand.atlassian.net/wiki/download/attachments/153485313/JCtVmzH8Hz_Pkuursye1VG3V1ZgpJ3RD-mcc8O-xIvJqLzSdhwhtBur_S9FziQzCpaCrHLqkhdHeGYUYS_zStVrzUK5Ly5eJTB_g3_J-qofKTbxEu-AF1bA-rlGKv3e2Aih60HosOU0?version=1&amp;modificationDate=1590030061501&amp;cacheVersion=1&amp;api=v2\" data-height=\"184\" data-width=\"511\" data-unresolved-comment-count=\"0\" data-linked-resource-id=\"191627295\" data-linked-resource-version=\"1\" data-linked-resource-type=\"attachment\" data-linked-resource-default-alias=\"JCtVmzH8Hz_Pkuursye1VG3V1ZgpJ3RD-mcc8O-xIvJqLzSdhwhtBur_S9FziQzCpaCrHLqkhdHeGYUYS_zStVrzUK5Ly5eJTB_g3_J-qofKTbxEu-AF1bA-rlGKv3e2Aih60HosOU0\" data-base-url=\"https://computhand.atlassian.net/wiki\" data-linked-resource-content-type=\"image/png\" data-linked-resource-container-id=\"153485313\" data-linked-resource-container-version=\"17\" data-media-id=\"240bf3ac-6341-4a60-b628-e6e6c7653af8\" data-media-type=\"file\"></span><p>*Nous verrons dans la prochaine section le principe de portée.</p><p /><h1 id=\"JavaInitial-Laprogrammationorientéeobjet\"><strong>La programmation orientée objet</strong></h1><h2 id=\"JavaInitial-Objectif\"><strong>Objectif</strong></h2><p>La programmation orientée objet est un modèle de langage de programmation qui s'articule autour d'objets et de données, plutôt que d'actions et de logique. Par le passé, un programme était une procédure logique qui récupérait des données en entrée, les traitait puis produisait des données en sortie.</p><p>L'enjeu de la programmation était d'écrire la logique, pas de définir les données. La programmation orientée objet a changé la perspective : l'important, ce sont les objets à manipuler plutôt que la logique nécessaire à cette manipulation</p><p><br/></p><h2 id=\"JavaInitial-ComparaisonPOOetlangageprocédural\"><strong>Comparaison POO et langage procédural</strong></h2><p><strong>Langage Procédural: </strong></p><ul><li><p>une seule entrée et sortie</p></li><li><p>enchaînement logique des instructions</p></li><li><p>une fois l’instruction précédente terminée.</p></li></ul><div class=\"ap-container conf-macro output-block\" id=\"ap-com.mxgraph.confluence.plugins.diagramly__drawio3951650042835294597\" data-hasbody=\"false\" data-macro-name=\"drawio\" data-macro-id=\"25a7dda3-9108-4f54-99a7-1ab6057dcece\" data-layout=\"default\" ac:local-id=\"4a0a9139-2157-45f0-88eb-49dd1d01ea4a\">\n\n  <div class=\"ap-content \" id=\"embedded-com.mxgraph.confluence.plugins.diagramly__drawio3951650042835294597\"> </div>\n  <script class=\"ap-iframe-body-script\">//<![CDATA[\n\n  (function(){\n    var data = {\n    \"addon_key\":\"com.mxgraph.confluence.plugins.diagramly\",\n    \"uniqueKey\":\"com.mxgraph.confluence.plugins.diagramly__drawio3951650042835294597\",\n    \"key\":\"drawio\",\n     \"moduleType\":\"dynamicContentMacros\",      \"moduleLocation\":\"content\",         \"cp\":\"/wiki\",\n            \"general\":\"\",\n    \"w\":\"\",\n    \"h\":\"\",\n    \"url\":\"https://ac.draw.io/connect/confluence/viewer-1-4-42.html?ceoId=153485313&diagramName=Untitled+Diagram.drawio&revision=2&width=320.5&height=461&tbstyle=&simple=0&lbox=1&zoom=1&links=&owningPageId=153485313&displayName=ProceduralLanguage.drawio&contentId=&custContentId=153550860&contentVer=2&inComment=0&aspect=&pCenter=0&hiRes=&templateUrl=&tmpBuiltIn=&xdm_e=https%3A%2F%2Fcomputhand.atlassian.net&xdm_c=channel-com.mxgraph.confluence.plugins.diagramly__drawio3951650042835294597&cp=%2Fwiki&xdm_deprecated_addon_key_do_not_use=com.mxgraph.confluence.plugins.diagramly&lic=active&cv=1.1008.0\",\n        \"structuredContext\": \"{\\\"license\\\":{\\\"active\\\":true},\\\"confluence\\\":{\\\"macro\\\":{\\\"outputType\\\":\\\"display\\\",\\\"hash\\\":\\\"25a7dda3-9108-4f54-99a7-1ab6057dcece\\\",\\\"id\\\":\\\"25a7dda3-9108-4f54-99a7-1ab6057dcece\\\"},\\\"content\\\":{\\\"type\\\":\\\"page\\\",\\\"version\\\":\\\"17\\\",\\\"id\\\":\\\"153485313\\\"},\\\"space\\\":{\\\"key\\\":\\\"FD\\\",\\\"id\\\":\\\"196609\\\"}}}\",\n    \"contentClassifier\":\"content\",\n    \"productCtx\":\"{\\\"page.id\\\":\\\"153485313\\\",\\\"macro.hash\\\":\\\"25a7dda3-9108-4f54-99a7-1ab6057dcece\\\",\\\"page.type\\\":\\\"page\\\",\\\"simple\\\":\\\"0\\\",\\\"inComment\\\":\\\"0\\\",\\\": = | RAW | = :\\\":\\\"zoom=1|simple=0|inComment=0|pageId=153485313|custContentId=153550860|lbox=1|diagramDisplayName=ProceduralLanguage.drawio|contentVer=2|revision=2|baseUrl=https://computhand.atlassian.net/wiki|diagramName=Untitled Diagram.drawio|pCenter=0|width=320.5|links=|tbstyle=|height=461\\\",\\\"space.id\\\":\\\"196609\\\",\\\"diagramDisplayName\\\":\\\"ProceduralLanguage.drawio\\\",\\\"diagramName\\\":\\\"Untitled Diagram.drawio\\\",\\\"links\\\":\\\"\\\",\\\"tbstyle\\\":\\\"\\\",\\\"height\\\":\\\"461\\\",\\\"space.key\\\":\\\"FD\\\",\\\"user.id\\\":\\\"5bf0df4bb11eb44b84a4f856\\\",\\\"content.version\\\":\\\"17\\\",\\\"page.title\\\":\\\"Java Initial\\\",\\\"zoom\\\":\\\"1\\\",\\\"macro.body\\\":\\\"\\\",\\\"pageId\\\":\\\"153485313\\\",\\\"custContentId\\\":\\\"153550860\\\",\\\"macro.truncated\\\":\\\"false\\\",\\\"lbox\\\":\\\"1\\\",\\\"content.type\\\":\\\"page\\\",\\\"output.type\\\":\\\"display\\\",\\\"contentVer\\\":\\\"2\\\",\\\"page.version\\\":\\\"17\\\",\\\"revision\\\":\\\"2\\\",\\\"user.key\\\":\\\"8a7f808970aa01cc0170b76bb56000e8\\\",\\\"baseUrl\\\":\\\"https://computhand.atlassian.net/wiki\\\",\\\"pCenter\\\":\\\"0\\\",\\\"content.id\\\":\\\"153485313\\\",\\\"width\\\":\\\"320.5\\\",\\\"macro.id\\\":\\\"25a7dda3-9108-4f54-99a7-1ab6057dcece\\\"}\",\n    \"timeZone\":\"America/Toronto\",\n    \"origin\":\"https://ac.draw.io\",\n    \"hostOrigin\":\"https://computhand.atlassian.net\",\n    \"sandbox\":\"allow-downloads allow-forms allow-modals allow-popups allow-scripts allow-same-origin allow-top-navigation-by-user-activation allow-storage-access-by-user-activation\",            \"apiMigrations\": {\n        \"gdpr\": true\n    }\n}\n;\n    if(window.AP && window.AP.subCreate) {\n      window._AP.appendConnectAddon(data);\n    } else {\n      require(['ac/create'], function(create){\n        create.appendConnectAddon(data);\n      });\n    }\n  }());\n\n//]]>\n</script>\n</div>\n<p><strong>POO:</strong></p><p>Programmation et principe</p><span class=\"confluence-embedded-file-wrapper image-left-wrapper confluence-embedded-manual-size\"><img class=\"confluence-embedded-image image-left\" width=\"340\" loading=\"lazy\" src=\"https://computhand.atlassian.net/wiki/download/thumbnails/153485313/JjpEIW5j410A7K68J_JxweRdE64ttPkXUDViqGtvxSYJZGQTkgUak2m3E5sQLyzNziwbt3BYEhtF4vnl_ir0tsO0uoGS1d9i0I49jhYwxnXTYoRiXqTW3RaL0wtljqyJNQR2Uh6tvA0?version=1&amp;modificationDate=1590088011262&amp;cacheVersion=1&amp;api=v2&amp;width=340&amp;height=325\" data-image-src=\"https://computhand.atlassian.net/wiki/download/attachments/153485313/JjpEIW5j410A7K68J_JxweRdE64ttPkXUDViqGtvxSYJZGQTkgUak2m3E5sQLyzNziwbt3BYEhtF4vnl_ir0tsO0uoGS1d9i0I49jhYwxnXTYoRiXqTW3RaL0wtljqyJNQR2Uh6tvA0?version=1&amp;modificationDate=1590088011262&amp;cacheVersion=1&amp;api=v2\" data-height=\"478\" data-width=\"500\" data-unresolved-comment-count=\"0\" data-linked-resource-id=\"193691651\" data-linked-resource-version=\"1\" data-linked-resource-type=\"attachment\" data-linked-resource-default-alias=\"JjpEIW5j410A7K68J_JxweRdE64ttPkXUDViqGtvxSYJZGQTkgUak2m3E5sQLyzNziwbt3BYEhtF4vnl_ir0tsO0uoGS1d9i0I49jhYwxnXTYoRiXqTW3RaL0wtljqyJNQR2Uh6tvA0\" data-base-url=\"https://computhand.atlassian.net/wiki\" data-linked-resource-content-type=\"image/png\" data-linked-resource-container-id=\"153485313\" data-linked-resource-container-version=\"17\" data-media-id=\"faa0d8f7-ab98-4f1e-b0d9-9d780740b53e\" data-media-type=\"file\" srcset=\"https://computhand.atlassian.net/wiki/download/thumbnails/153485313/JjpEIW5j410A7K68J_JxweRdE64ttPkXUDViqGtvxSYJZGQTkgUak2m3E5sQLyzNziwbt3BYEhtF4vnl_ir0tsO0uoGS1d9i0I49jhYwxnXTYoRiXqTW3RaL0wtljqyJNQR2Uh6tvA0?version=1&amp;modificationDate=1590088011262&amp;cacheVersion=1&amp;api=v2&amp;width=500&amp;height=478 2x, https://computhand.atlassian.net/wiki/download/thumbnails/153485313/JjpEIW5j410A7K68J_JxweRdE64ttPkXUDViqGtvxSYJZGQTkgUak2m3E5sQLyzNziwbt3BYEhtF4vnl_ir0tsO0uoGS1d9i0I49jhYwxnXTYoRiXqTW3RaL0wtljqyJNQR2Uh6tvA0?version=1&amp;modificationDate=1590088011262&amp;cacheVersion=1&amp;api=v2&amp;width=340&amp;height=325 1x\"></span><span class=\"confluence-embedded-file-wrapper image-right-wrapper confluence-embedded-manual-size\"><img class=\"confluence-embedded-image image-right\" width=\"340\" loading=\"lazy\" src=\"https://computhand.atlassian.net/wiki/download/thumbnails/153485313/PZqfhD-IumE7L5MLhgGEOzeL9HCZyaujQTz2HItIUIBwzUkA4znW-f0zMtAZyoIZ8Wn4bMXjTm_Qyjsc5yO-X_7IEMpEA9GYLpZ4HkBFQUWE67Y302jUG55xO917UCmtNuwmAXeisBI?version=1&amp;modificationDate=1590030180535&amp;cacheVersion=1&amp;api=v2&amp;width=340&amp;height=136\" data-image-src=\"https://computhand.atlassian.net/wiki/download/attachments/153485313/PZqfhD-IumE7L5MLhgGEOzeL9HCZyaujQTz2HItIUIBwzUkA4znW-f0zMtAZyoIZ8Wn4bMXjTm_Qyjsc5yO-X_7IEMpEA9GYLpZ4HkBFQUWE67Y302jUG55xO917UCmtNuwmAXeisBI?version=1&amp;modificationDate=1590030180535&amp;cacheVersion=1&amp;api=v2\" data-height=\"411\" data-width=\"1024\" data-unresolved-comment-count=\"0\" data-linked-resource-id=\"191660089\" data-linked-resource-version=\"1\" data-linked-resource-type=\"attachment\" data-linked-resource-default-alias=\"PZqfhD-IumE7L5MLhgGEOzeL9HCZyaujQTz2HItIUIBwzUkA4znW-f0zMtAZyoIZ8Wn4bMXjTm_Qyjsc5yO-X_7IEMpEA9GYLpZ4HkBFQUWE67Y302jUG55xO917UCmtNuwmAXeisBI\" data-base-url=\"https://computhand.atlassian.net/wiki\" data-linked-resource-content-type=\"image/png\" data-linked-resource-container-id=\"153485313\" data-linked-resource-container-version=\"17\" data-media-id=\"6c1adb95-e019-442a-8d8c-ffd0b89ac539\" data-media-type=\"file\" srcset=\"https://computhand.atlassian.net/wiki/download/thumbnails/153485313/PZqfhD-IumE7L5MLhgGEOzeL9HCZyaujQTz2HItIUIBwzUkA4znW-f0zMtAZyoIZ8Wn4bMXjTm_Qyjsc5yO-X_7IEMpEA9GYLpZ4HkBFQUWE67Y302jUG55xO917UCmtNuwmAXeisBI?version=1&amp;modificationDate=1590030180535&amp;cacheVersion=1&amp;api=v2&amp;width=680&amp;height=272 2x, https://computhand.atlassian.net/wiki/download/thumbnails/153485313/PZqfhD-IumE7L5MLhgGEOzeL9HCZyaujQTz2HItIUIBwzUkA4znW-f0zMtAZyoIZ8Wn4bMXjTm_Qyjsc5yO-X_7IEMpEA9GYLpZ4HkBFQUWE67Y302jUG55xO917UCmtNuwmAXeisBI?version=1&amp;modificationDate=1590030180535&amp;cacheVersion=1&amp;api=v2&amp;width=340&amp;height=136 1x\"></span><p style=\"text-align: center;\">                                                                                       Exécution en Java</p><p style=\"text-align: center;\" /><h2 id=\"JavaInitial-Classeetobjet\"><strong>Classe et objet</strong></h2><div class=\"ap-container conf-macro output-block\" id=\"ap-com.mxgraph.confluence.plugins.diagramly__drawio5430443920706486834\" data-hasbody=\"false\" data-macro-name=\"drawio\" data-macro-id=\"e77d6d00-7842-458b-8793-cbb7d2cd15b5\" data-layout=\"default\" ac:local-id=\"632b2c3a-14d0-425f-aab7-e31994789f36\">\n\n  <div class=\"ap-content \" id=\"embedded-com.mxgraph.confluence.plugins.diagramly__drawio5430443920706486834\"> </div>\n  <script class=\"ap-iframe-body-script\">//<![CDATA[\n\n  (function(){\n    var data = {\n    \"addon_key\":\"com.mxgraph.confluence.plugins.diagramly\",\n    \"uniqueKey\":\"com.mxgraph.confluence.plugins.diagramly__drawio5430443920706486834\",\n    \"key\":\"drawio\",\n     \"moduleType\":\"dynamicContentMacros\",      \"moduleLocation\":\"content\",         \"cp\":\"/wiki\",\n            \"general\":\"\",\n    \"w\":\"\",\n    \"h\":\"\",\n    \"url\":\"https://ac.draw.io/connect/confluence/viewer-1-4-42.html?ceoId=153485313&diagramName=ObjectOriented.drawio&revision=1&width=681&height=421&tbstyle=&simple=0&lbox=1&zoom=1&links=&owningPageId=153485313&displayName=ObjectOriented.drawio&contentId=&custContentId=167575643&contentVer=1&inComment=0&aspect=&pCenter=0&hiRes=&templateUrl=&tmpBuiltIn=&xdm_e=https%3A%2F%2Fcomputhand.atlassian.net&xdm_c=channel-com.mxgraph.confluence.plugins.diagramly__drawio5430443920706486834&cp=%2Fwiki&xdm_deprecated_addon_key_do_not_use=com.mxgraph.confluence.plugins.diagramly&lic=active&cv=1.1008.0\",\n        \"structuredContext\": \"{\\\"license\\\":{\\\"active\\\":true},\\\"confluence\\\":{\\\"macro\\\":{\\\"outputType\\\":\\\"display\\\",\\\"hash\\\":\\\"e77d6d00-7842-458b-8793-cbb7d2cd15b5\\\",\\\"id\\\":\\\"e77d6d00-7842-458b-8793-cbb7d2cd15b5\\\"},\\\"content\\\":{\\\"type\\\":\\\"page\\\",\\\"version\\\":\\\"17\\\",\\\"id\\\":\\\"153485313\\\"},\\\"space\\\":{\\\"key\\\":\\\"FD\\\",\\\"id\\\":\\\"196609\\\"}}}\",\n    \"contentClassifier\":\"content\",\n    \"productCtx\":\"{\\\"page.id\\\":\\\"153485313\\\",\\\"macro.hash\\\":\\\"e77d6d00-7842-458b-8793-cbb7d2cd15b5\\\",\\\"page.type\\\":\\\"page\\\",\\\"simple\\\":\\\"0\\\",\\\"inComment\\\":\\\"0\\\",\\\": = | RAW | = :\\\":\\\"zoom=1|simple=0|inComment=0|pageId=153485313|custContentId=167575643|lbox=1|diagramDisplayName=ObjectOriented.drawio|contentVer=1|revision=1|baseUrl=https://computhand.atlassian.net/wiki|diagramName=ObjectOriented.drawio|pCenter=0|width=681|links=|tbstyle=|height=421\\\",\\\"space.id\\\":\\\"196609\\\",\\\"diagramDisplayName\\\":\\\"ObjectOriented.drawio\\\",\\\"diagramName\\\":\\\"ObjectOriented.drawio\\\",\\\"links\\\":\\\"\\\",\\\"tbstyle\\\":\\\"\\\",\\\"height\\\":\\\"421\\\",\\\"space.key\\\":\\\"FD\\\",\\\"user.id\\\":\\\"5bf0df4bb11eb44b84a4f856\\\",\\\"content.version\\\":\\\"17\\\",\\\"page.title\\\":\\\"Java Initial\\\",\\\"zoom\\\":\\\"1\\\",\\\"macro.body\\\":\\\"\\\",\\\"pageId\\\":\\\"153485313\\\",\\\"custContentId\\\":\\\"167575643\\\",\\\"macro.truncated\\\":\\\"false\\\",\\\"lbox\\\":\\\"1\\\",\\\"content.type\\\":\\\"page\\\",\\\"output.type\\\":\\\"display\\\",\\\"contentVer\\\":\\\"1\\\",\\\"page.version\\\":\\\"17\\\",\\\"revision\\\":\\\"1\\\",\\\"user.key\\\":\\\"8a7f808970aa01cc0170b76bb56000e8\\\",\\\"baseUrl\\\":\\\"https://computhand.atlassian.net/wiki\\\",\\\"pCenter\\\":\\\"0\\\",\\\"content.id\\\":\\\"153485313\\\",\\\"width\\\":\\\"681\\\",\\\"macro.id\\\":\\\"e77d6d00-7842-458b-8793-cbb7d2cd15b5\\\"}\",\n    \"timeZone\":\"America/Toronto\",\n    \"origin\":\"https://ac.draw.io\",\n    \"hostOrigin\":\"https://computhand.atlassian.net\",\n    \"sandbox\":\"allow-downloads allow-forms allow-modals allow-popups allow-scripts allow-same-origin allow-top-navigation-by-user-activation allow-storage-access-by-user-activation\",            \"apiMigrations\": {\n        \"gdpr\": true\n    }\n}\n;\n    if(window.AP && window.AP.subCreate) {\n      window._AP.appendConnectAddon(data);\n    } else {\n      require(['ac/create'], function(create){\n        create.appendConnectAddon(data);\n      });\n    }\n  }());\n\n//]]>\n</script>\n</div>\n<p>En <a href=\"https://fr.wikipedia.org/wiki/Programmation_orient%C3%A9e_objet\" class=\"external-link\" rel=\"nofollow\">programmation orientée objet</a>, la <a href=\"https://fr.wikipedia.org/wiki/D%C3%A9claration_(informatique)\" class=\"external-link\" rel=\"nofollow\">déclaration</a> d'une classe regroupe des membres, <a href=\"https://fr.wikipedia.org/wiki/M%C3%A9thode_(informatique)\" class=\"external-link\" rel=\"nofollow\">méthodes</a> et <a href=\"https://fr.wikipedia.org/wiki/Propri%C3%A9t%C3%A9_(informatique)\" class=\"external-link\" rel=\"nofollow\">propriétés</a> (attributs) communs à un ensemble d'<a href=\"https://fr.wikipedia.org/wiki/Objet_(informatique)\" class=\"external-link\" rel=\"nofollow\">objets</a>.</p><p>La classe déclare, d'une part, des attributs représentant l'état des objets et, d'autre part, des <a href=\"https://fr.wikipedia.org/wiki/M%C3%A9thode_(informatique)\" class=\"external-link\" rel=\"nofollow\">méthodes</a> représentant leur comportement.</p><p>Une classe représente donc une catégorie d'objets. Elle apparaît aussi comme un moule ou une usine à partir de laquelle il est possible de créer des objets ; c'est en quelque sorte une « boîte à outils » qui permet de fabriquer un objet. On parle alors d'un objet en tant qu'<a href=\"https://fr.wikipedia.org/wiki/Instance_(programmation)\" class=\"external-link\" rel=\"nofollow\">instance</a> d'une classe (création d'un objet ayant les propriétés de la classe).</p><h4 id=\"JavaInitial-Propriétéd’uneclasse\">Propriété d’une classe</h4><div class=\"table-wrap\"><table data-layout=\"default\" class=\"confluenceTable\"><colgroup><col style=\"width: 340.0px;\"/><col style=\"width: 340.0px;\"/></colgroup><tbody><tr><td data-highlight-colour=\"#fcfcfc\" class=\"confluenceTd\"><p><strong>Portion</strong></p></td><td data-highlight-colour=\"#fcfcfc\" class=\"confluenceTd\"><p><strong>Description</strong></p></td></tr><tr><td data-highlight-colour=\"#f3f6f6\" class=\"confluenceTd\"><p>Visibilité</p></td><td data-highlight-colour=\"#f3f6f6\" class=\"confluenceTd\"><p>Permet de cacher certaines classes à d'autres classes du programme.</p></td></tr><tr><td data-highlight-colour=\"#fcfcfc\" class=\"confluenceTd\"><p>Options</p></td><td data-highlight-colour=\"#fcfcfc\" class=\"confluenceTd\"><p>Les options permettent de changer la façon dont la classe peut se comporter mais aussi comment elle peut être modifiée.</p></td></tr><tr><td data-highlight-colour=\"#f3f6f6\" class=\"confluenceTd\"><p>Nom de la classe</p></td><td data-highlight-colour=\"#f3f6f6\" class=\"confluenceTd\"><p>L'identifiant que vous attribuez à la classe, il doit être unique dans le package du programme.</p></td></tr><tr><td data-highlight-colour=\"#fcfcfc\" class=\"confluenceTd\"><p>Autres Options</p></td><td data-highlight-colour=\"#fcfcfc\" class=\"confluenceTd\"><p>Les interfaces, les héritages, les génériques, etc.</p></td></tr><tr><td data-highlight-colour=\"#f3f6f6\" class=\"confluenceTd\"><p>Code</p></td><td data-highlight-colour=\"#f3f6f6\" class=\"confluenceTd\"><p>Le code qui sera utilisé pour déclarer et définir des variables et des fonctions.</p></td></tr></tbody></table></div><p /><h2 id=\"JavaInitial-Méthodesetattributs\"><strong>Méthodes et attributs</strong></h2><h4 id=\"JavaInitial-Définitiond’uneméthode\">Définition d’une méthode</h4><p>On appelle fonction un sous-programme qui permet d'effectuer un ensemble d'instructions par simple appel de la fonction dans le corps du programme principal. Les fonctions permettent d'exécuter dans plusieurs parties du programme une série d'instructions, cela permet une simplicité du code et donc une taille de programme minimale. D'autre part, une fonction peut faire appel à elle-même, on parle alors de fonction récursive (il ne faut pas oublier de mettre une condition de sortie au risque sinon de ne pas pouvoir arrêter le programme...).</p><h4 id=\"JavaInitial-Proprieted’uneméthodes\">Propriete d’une méthodes</h4><div class=\"table-wrap\"><table data-layout=\"default\" class=\"confluenceTable\"><colgroup><col style=\"width: 340.0px;\"/><col style=\"width: 340.0px;\"/></colgroup><tbody><tr><td data-highlight-colour=\"#fcfcfc\" class=\"confluenceTd\"><p><strong>Portion</strong></p></td><td data-highlight-colour=\"#fcfcfc\" class=\"confluenceTd\"><p><strong>Description</strong></p></td></tr><tr><td data-highlight-colour=\"#f3f6f6\" class=\"confluenceTd\"><p>Visibilité</p></td><td data-highlight-colour=\"#f3f6f6\" class=\"confluenceTd\"><p>Permet de cacher certaines fonctions à d'autres fonctions ou classes.</p></td></tr><tr><td data-highlight-colour=\"#fcfcfc\" class=\"confluenceTd\"><p>Options</p></td><td data-highlight-colour=\"#fcfcfc\" class=\"confluenceTd\"><p>Les options permettent de changer la façon dont la fonction peut se comporter mais aussi comment elle peut être modifiée. Mot clé static, final</p></td></tr><tr><td data-highlight-colour=\"#f3f6f6\" class=\"confluenceTd\"><p>Type de retour</p></td><td data-highlight-colour=\"#f3f6f6\" class=\"confluenceTd\"><p>Le type de retour est un identifiant d'un type primitif ou complexe. Vous pouvez définir vos propres types complexes. Si la méthode ne retourne pas de valeur on écrit void à cet emplacement.</p></td></tr><tr><td data-highlight-colour=\"#fcfcfc\" class=\"confluenceTd\"><p>Nom de la fonction</p></td><td data-highlight-colour=\"#fcfcfc\" class=\"confluenceTd\"><p>L'identifiant que vous attribuez à la fonction: il doit être unique dans la classe.</p></td></tr><tr><td data-highlight-colour=\"#f3f6f6\" class=\"confluenceTd\"><p>Arguments...</p></td><td data-highlight-colour=\"#f3f6f6\" class=\"confluenceTd\"><p>Liste des arguments qui sont nécessaires pour appeler cette fonction. Ils permettent de changer le comportement de celle-ci.</p></td></tr><tr><td data-highlight-colour=\"#fcfcfc\" class=\"confluenceTd\"><p>Code</p></td><td data-highlight-colour=\"#fcfcfc\" class=\"confluenceTd\"><p>Le code qui sera exécuté lorsque la fonction sera appelée.</p></td></tr></tbody></table></div><p /><h4 id=\"JavaInitial-Définitiond’unAttribut\">Définition d’un Attribut</h4><p> les attributs sont des entités qui définissent les <a href=\"https://fr.wikipedia.org/wiki/Propri%C3%A9t%C3%A9_(informatique)\" class=\"external-link\" rel=\"nofollow\">propriétés</a> d'objets. Les attributs sont habituellement composés d'un <a href=\"https://fr.wikipedia.org/wiki/Identificateur\" class=\"external-link\" rel=\"nofollow\">identificateur</a>, d’une portée et d’un type.</p><p>Propriete d’un Attribut</p><div class=\"table-wrap\"><table data-layout=\"default\" class=\"confluenceTable\"><colgroup><col style=\"width: 340.0px;\"/><col style=\"width: 340.0px;\"/></colgroup><tbody><tr><td data-highlight-colour=\"#fcfcfc\" class=\"confluenceTd\"><p><strong>Portion</strong></p></td><td data-highlight-colour=\"#fcfcfc\" class=\"confluenceTd\"><p><strong>Description</strong></p></td></tr><tr><td data-highlight-colour=\"#ffffff\" class=\"confluenceTd\"><p>Visibilité</p></td><td data-highlight-colour=\"#ffffff\" class=\"confluenceTd\"><p>Permet de cacher certains attributs à d'autres fonctions ou classes.</p></td></tr><tr><td data-highlight-colour=\"#f3f6f6\" class=\"confluenceTd\"><p>Options</p></td><td data-highlight-colour=\"#f3f6f6\" class=\"confluenceTd\"><p>Les options permettent de changer la façon dont l’attribut peut se comporter mais aussi comment il peut être modifié. Mot clé static, final</p></td></tr><tr><td data-highlight-colour=\"#ffffff\" class=\"confluenceTd\"><p>Type de l’attribut</p></td><td data-highlight-colour=\"#ffffff\" class=\"confluenceTd\"><p>Le type de l’attribut est un identifiant d'un type primitif ou complexe. Vous pouvez définir vos propres types complexes.</p></td></tr><tr><td data-highlight-colour=\"#f3f6f6\" class=\"confluenceTd\"><p>Nom de l’attribut</p></td><td data-highlight-colour=\"#f3f6f6\" class=\"confluenceTd\"><p>L'identifiant que vous attribuez à l’attribut: il doit être unique dans la classe.</p></td></tr></tbody></table></div><div class=\"confluence-information-macro confluence-information-macro-note conf-macro output-block\" data-hasbody=\"true\" data-macro-name=\"note\" data-macro-id=\"35e2e46e-9f4e-4f6e-94a6-69f894536d8b\"><span class=\"aui-icon aui-icon-small aui-iconfont-warning confluence-information-macro-icon\"> </span><div class=\"confluence-information-macro-body\"><p>*<span style=\"color: rgb(191,38,0);\">static</span>: indique que l’élément ne nécessite pas d’instanciation.</p><p>*<span style=\"color: rgb(191,38,0);\">final</span>: indique qu'un élément ne peut être changé dans la suite du programme.</p></div></div><h2 id=\"JavaInitial-Relationsentreclasses\"><strong>Relations entre classes</strong></h2><h3 id=\"JavaInitial-Visibilité\">Visibilité</h3><p>Lorsque vous déclarez quelque chose <span style=\"color: rgb(191,38,0);\">public</span>, tout le monde peut y avoir accès sans réserve. Par contre, si vous déclarez quelque chose <span style=\"color: rgb(191,38,0);\">private</span>, alors, plus personne ne peut utiliser cet élément. Il existe un entre deux pour autoriser les programmeurs à réutiliser votre code sans toutefois qu'il soit <span style=\"color: rgb(191,38,0);\">public</span>, cette visibilité est <span style=\"color: rgb(191,38,0);\">protected</span>.</p><p>Un élément <span style=\"color: rgb(191,38,0);\">protected </span>n'est pas disponible à l'extérieur d'une classe mais si vous étendez cette classe par une autre, alors la nouvelle classe aura accès aux propriétés <span style=\"color: rgb(191,38,0);\">public </span>et <span style=\"color: rgb(191,38,0);\">protected</span>.</p><p>Lorsqu'il n'y a pas de modificateur, on dit que la visibilité est la visibilité par défaut. elle n'est visible alors que de son propre package.</p><h3 id=\"JavaInitial-Heritage\">Heritage</h3><span class=\"confluence-embedded-file-wrapper image-left-wrap-wrapper confluence-embedded-manual-size\"><img class=\"confluence-embedded-image image-wrap-left\" width=\"340\" loading=\"lazy\" src=\"https://computhand.atlassian.net/wiki/download/thumbnails/153485313/1wNXZtiFm6cB7mTRbv3LUuHUQxYRD6i-bB-YXRdSBeHTzy179cnsd_WtL9ATxZMqykfyAhoo69zL-p_YfvPUlAJdv96eGqOkjb3M-1HsvnPj3TjyQAHpVna-SzZGlCZ2A-A1G_0qmsE?version=1&amp;modificationDate=1590031044114&amp;cacheVersion=1&amp;api=v2&amp;width=312&amp;height=169\" data-image-src=\"https://computhand.atlassian.net/wiki/download/attachments/153485313/1wNXZtiFm6cB7mTRbv3LUuHUQxYRD6i-bB-YXRdSBeHTzy179cnsd_WtL9ATxZMqykfyAhoo69zL-p_YfvPUlAJdv96eGqOkjb3M-1HsvnPj3TjyQAHpVna-SzZGlCZ2A-A1G_0qmsE?version=1&amp;modificationDate=1590031044114&amp;cacheVersion=1&amp;api=v2\" data-height=\"169\" data-width=\"312\" data-unresolved-comment-count=\"0\" data-linked-resource-id=\"191627319\" data-linked-resource-version=\"1\" data-linked-resource-type=\"attachment\" data-linked-resource-default-alias=\"1wNXZtiFm6cB7mTRbv3LUuHUQxYRD6i-bB-YXRdSBeHTzy179cnsd_WtL9ATxZMqykfyAhoo69zL-p_YfvPUlAJdv96eGqOkjb3M-1HsvnPj3TjyQAHpVna-SzZGlCZ2A-A1G_0qmsE\" data-base-url=\"https://computhand.atlassian.net/wiki\" data-linked-resource-content-type=\"image/png\" data-linked-resource-container-id=\"153485313\" data-linked-resource-container-version=\"17\" data-media-id=\"a4693251-1aeb-4888-a5a2-ef50b7e3292c\" data-media-type=\"file\" srcset=\"https://computhand.atlassian.net/wiki/download/thumbnails/153485313/1wNXZtiFm6cB7mTRbv3LUuHUQxYRD6i-bB-YXRdSBeHTzy179cnsd_WtL9ATxZMqykfyAhoo69zL-p_YfvPUlAJdv96eGqOkjb3M-1HsvnPj3TjyQAHpVna-SzZGlCZ2A-A1G_0qmsE?version=1&amp;modificationDate=1590031044114&amp;cacheVersion=1&amp;api=v2&amp;width=312&amp;height=169 2x, https://computhand.atlassian.net/wiki/download/thumbnails/153485313/1wNXZtiFm6cB7mTRbv3LUuHUQxYRD6i-bB-YXRdSBeHTzy179cnsd_WtL9ATxZMqykfyAhoo69zL-p_YfvPUlAJdv96eGqOkjb3M-1HsvnPj3TjyQAHpVna-SzZGlCZ2A-A1G_0qmsE?version=1&amp;modificationDate=1590031044114&amp;cacheVersion=1&amp;api=v2&amp;width=312&amp;height=169 1x\"></span><p>L'héritage est un mécanisme permettant de créer une nouvelle classe à partir d'une classe existante en lui proférant ses propriétés et ses méthodes.</p><p>Ainsi, pour définir une nouvelle classe, il suffit de la faire hériter d'une classe existante et de lui ajouter de nouvelles propriétés/méthodes.</p><p>On utilise les mots cles <span style=\"color: rgb(191,38,0);\">extends </span>et <span style=\"color: rgb(191,38,0);\">implements </span>pour les mettre en place</p><div class=\"code panel pdl conf-macro output-block\" style=\"border-width: 1px;\" data-hasbody=\"true\" data-macro-name=\"code\" data-macro-id=\"8c60ab36-fd73-4a09-a1fd-973c15e4e4d4\"><div class=\"codeContent panelContent pdl\">\n<pre class=\"syntaxhighlighter-pre\" data-syntaxhighlighter-params=\"brush: java; gutter: false; theme: Confluence\" data-theme=\"Confluence\">class A {\n    public String publicSayHelloTo(String something) {\n        System.out.println(&quot;Hello &quot; + something);\n    }\n    protected String protectedSayHelloTo(String something) {\n        System.out.println(&quot;Hello &quot; + something);\n    }\n    private String privateSayHelloTo(String something) {\n        System.out.println(&quot;Hello &quot; + something);\n    }\n}</pre>\n</div></div><div class=\"code panel pdl conf-macro output-block\" style=\"border-width: 1px;\" data-hasbody=\"true\" data-macro-name=\"code\" data-macro-id=\"8058f2e0-a136-4af4-b0e1-5a6a5cd855c4\"><div class=\"codeContent panelContent pdl\">\n<pre class=\"syntaxhighlighter-pre\" data-syntaxhighlighter-params=\"brush: java; gutter: false; theme: Confluence\" data-theme=\"Confluence\">class B extends A {\n    // Vous pouvez utiliser publicSayHelloTo et protectedSayHelloTo\n    // Vous ne pouvez pas utiliser privateSayHelloTo\n}</pre>\n</div></div><div class=\"code panel pdl conf-macro output-block\" style=\"border-width: 1px;\" data-hasbody=\"true\" data-macro-name=\"code\" data-macro-id=\"5f4f6c90-8ed6-4fac-bee9-f1ee7ef60ff2\"><div class=\"codeContent panelContent pdl\">\n<pre class=\"syntaxhighlighter-pre\" data-syntaxhighlighter-params=\"brush: java; gutter: false; theme: Confluence\" data-theme=\"Confluence\">class C {\n    // Vous pouvez utiliser publicSayHelloTo si vous avez une instance de A ou B\n    // Vous ne pouvez pas utiliser protectedSayHelloTo ou privateSayHelloTo\n}</pre>\n</div></div><p>Un autre concept important est que si vous remplacez une fonction avec <span style=\"color: rgb(191,38,0);\">@Override</span> vous pouvez changer la visibilité d'une fonction. Vous ne pouvez pas réduire la visibilité mais vous pouvez l'améliorer. Par exemple:</p><div class=\"code panel pdl conf-macro output-block\" style=\"border-width: 1px;\" data-hasbody=\"true\" data-macro-name=\"code\" data-macro-id=\"1913ea45-9ae3-4c6d-8dc5-9daa8ea7a9af\"><div class=\"codeContent panelContent pdl\">\n<pre class=\"syntaxhighlighter-pre\" data-syntaxhighlighter-params=\"brush: java; gutter: false; theme: Confluence\" data-theme=\"Confluence\">class A {\n\n    public String publicSayHelloTo(String something) {\n        System.out.println(&quot;Hello &quot; + something);\n    }\n\n    protected String protectedSayHelloTo(String something) {\n        System.out.println(&quot;Hello &quot; + something);\n    }\n\n    private String privateSayHelloTo(String something) {\n        System.out.println(&quot;Hello &quot; + something);\n    }\n\n}</pre>\n</div></div><div class=\"code panel pdl conf-macro output-block\" style=\"border-width: 1px;\" data-hasbody=\"true\" data-macro-name=\"code\" data-macro-id=\"2e76ffb3-76f9-4eb3-8a77-818315e31bc6\"><div class=\"codeContent panelContent pdl\">\n<pre class=\"syntaxhighlighter-pre\" data-syntaxhighlighter-params=\"brush: java; gutter: false; theme: Confluence\" data-theme=\"Confluence\">class B extends A {\n\n    // Ici, on rends protectedSayHelloTo publique\n    @Override\n    public String protectedSayHelloTo(String something) {\n        System.out.println(&quot;Hello &quot; + something);\n    }\n\n    // Erreur, ceci est impossible car vous n'y avez même pas accès vous même\n    @Override\n    public String privateSayHelloTo(String something) {\n        System.out.println(&quot;Hello &quot; + something);\n    }\n}</pre>\n</div></div><div class=\"confluence-information-macro confluence-information-macro-note conf-macro output-block\" data-hasbody=\"true\" data-macro-name=\"note\" data-macro-id=\"d732c0f6-f85e-46e7-9577-2b9475ab916a\"><span class=\"aui-icon aui-icon-small aui-iconfont-warning confluence-information-macro-icon\"> </span><div class=\"confluence-information-macro-body\"><p>on peut étendre plusieurs classes mais on ne peut pas implémenter plusieurs interfaces en java</p></div></div><h3 id=\"JavaInitial-Notiond’interface\"><strong>Notion d’interface</strong></h3><ul><li><p>Liste de méthodes dont on donne seulement la signature</p></li><li><p>Représente un &quot;contrat&quot;, ce qu'on attend d'un objet</p></li><li><p>Peut être implémentée par une ou plusieurs classes qui doivent donner une implémentation pour chacune des méthodes annoncées (et éventuellement d'autres).</p></li><li><p>Une classe peut implémenter plusieurs interfaces (permettant un héritage multiple, en les séparant par des virgules après le mot implements).</p></li><li><p>Toutes les méthodes d'une interface sont implicitement abstraites.</p></li><li><p>Une interface n'a pas de constructeurs</p></li><li><p>Une interface ne peut avoir de champs sauf si ceux-ci sont statiques.</p></li><li><p>Une interface peut être étendue par une ou plusieurs autre(s) interface(s).</p></li></ul><h4 id=\"JavaInitial-InterfaceFonctionnelle\">Interface Fonctionnelle</h4><p>Java 8 introduit le concept d’”interface fonctionnelle” qui permet de définir une interface disposant d’une unique méthode abstraite, c’est-à-dire une seule méthode ne possédant pas d’<a href=\"http://docs.oracle.com/javase/tutorial/java/IandI/defaultmethods.html\" class=\"external-link\" rel=\"nofollow\">implémentation par défaut</a>.</p><p>Le but d’une interface fonctionnelle est de définir la signature d’une méthode qui pourra être utilisée pour passer en paramètre :</p><ul><li><p>une référence vers une méthode statique</p></li><li><p>une référence vers une méthode d’instance</p></li><li><p>une référence vers un constructeur</p></li><li><p>une expression lambda.</p></li></ul><p>Même si ce n’est pas obligatoire, le JDK permet de vérifier le contrat “une seule méthode abstraite” en appliquant l’annotation <a href=\"http://download.java.net/jdk8/docs/api/java/lang/FunctionalInterface.html\" class=\"external-link\" rel=\"nofollow\">@FunctionalInterface</a></p><div class=\"code panel pdl conf-macro output-block\" style=\"border-width: 1px;\" data-hasbody=\"true\" data-macro-name=\"code\" data-macro-id=\"45268bec-a90d-497c-85ea-e7b5e704680f\"><div class=\"codeContent panelContent pdl\">\n<pre class=\"syntaxhighlighter-pre\" data-syntaxhighlighter-params=\"brush: java; gutter: false; theme: Confluence\" data-theme=\"Confluence\">@FunctionalInterface\npublic interface ExampleInterface {\n    void doSomething();\n    default int methodWithDefaultImpl() { return 0; }\n}</pre>\n</div></div><p>Si vous définissez plusieurs méthodes abstraites, le compilateur génèrera une erreur du type :</p><div class=\"code panel pdl conf-macro output-block\" style=\"border-width: 1px;\" data-hasbody=\"true\" data-macro-name=\"code\" data-macro-id=\"f55d4246-8019-462a-958d-c0f18f062840\"><div class=\"codeContent panelContent pdl\">\n<pre class=\"syntaxhighlighter-pre\" data-syntaxhighlighter-params=\"brush: java; gutter: false; theme: Confluence\" data-theme=\"Confluence\">Unexpected @FunctionalInterface annotation\nExampleInterface is not a functional interface\nmultiple non-overriding abstract methods found in interface ExampleInterface</pre>\n</div></div><h3 id=\"JavaInitial-Classeabstraite\"><strong>Classe abstraite</strong></h3><ul><li><p>Une classe abstraite se trouve à mi-chemin entre les interfaces et les classes.</p></li><li><p>Les classes abstraites, comme les interfaces, ne sont pas instanciables.</p></li><li><p>Les classes abstraites sont déclarées par le modificateur abstract.</p></li><li><p>Il y a plusieurs intérêts à définir des classes abstraites :</p><ul><li><p>pour interdire l'instanciation d'une classe ;</p></li><li><p>pour faire de la factorisation de code en ne donnant qu'une implémentation partielle.</p></li></ul></li></ul><div class=\"code panel pdl conf-macro output-block\" style=\"border-width: 1px;\" data-hasbody=\"true\" data-macro-name=\"code\" data-macro-id=\"e0a735c4-04ef-42e9-b4de-05f9913dcbee\"><div class=\"codeContent panelContent pdl\">\n<pre class=\"syntaxhighlighter-pre\" data-syntaxhighlighter-params=\"brush: java; gutter: false; theme: Confluence\" data-theme=\"Confluence\">interface Dog {\n\n\tvoid toGetOld();\n\n\tvoid bark();\n}</pre>\n</div></div><p>On sait que la méthode toGetOld sera implémentée de la même manière quelle que soit l'implémentation de Dog. Plutôt que d'implémenter cette interface à chaque fois, on va factoriser le code dans une classe abstraite et étendre cette classe quand le besoin s'en fait sentir. On crée donc une classe AbstractDog qui n'implémente que la méthode vieillir de notre interface, les autres étant laissées abstract.</p><div class=\"code panel pdl conf-macro output-block\" style=\"border-width: 1px;\" data-hasbody=\"true\" data-macro-name=\"code\" data-macro-id=\"ac9b528a-9f4f-45c2-9a7f-0162e7ce8c54\"><div class=\"codeContent panelContent pdl\">\n<pre class=\"syntaxhighlighter-pre\" data-syntaxhighlighter-params=\"brush: java; gutter: false; theme: Confluence\" data-theme=\"Confluence\">public abstract class AbstractDog implements Dog {\n\t// Champs\n\t// On met les champs en protected pour que les classes filles\n\t// puissent les manipuler directement\n\tprotected int age;\n\tprotected String color;\n\t\n\tpublic AbstractDog() {\n\t\t\n\t}\n\t\n\t// Constructeur\n\t// Pourra être utilisé par les classes filles pour initialiser les champs.\n\tpublic AbstractDog(int age, String color) {\n\t\tthis.age = age;\n\t\tthis.color = color;\n\t}\n\n\t// Méthode\n\n\t// On donne l'implémentation qui est commune à tous les chiens\n\tpublic void toGetOld() {\n\t\tage++;\n\t}\n\n\t// Cette méthode n'est définie que par les classes filles\n\t// Elle est donc laissée abstract.\n\tpublic abstract void bark();\n\n}</pre>\n</div></div><h3 id=\"JavaInitial-Redéfinitionetsurcharge\">Redéfinition et surcharge</h3><p><strong>La surcharge:</strong><em><strong><span style=\"color: rgb(191,38,0);\">@Overload</span></strong></em></p><p>La surcharge d’une méthode ou d’un constructeur permet de définir plusieurs fois une même méthode/constructeur avec des arguments différents.</p><p>Le compilateur choisit la méthode qui doit être appelée en fonction du nombre et du type des arguments .<br/></p><p><strong>La redéfinition:</strong><em><strong><span style=\"color: rgb(191,38,0);\">@Override</span></strong></em></p><p>La redéfinition d’une méthode héritée doit impérativement conserver la déclaration de la méthode parent (type et nombre de paramètres, la valeur de retour et les exceptions propagées doivent être identiques).</p><p>Si la signature de la méthode change, ce n’est plus une redéfinition mais une surcharge. Cette nouvelle méthode n’est pas héritée : la classe mère ne possède pas de méthode possédant cette signature .</p><h3 id=\"JavaInitial-ArrangementdesClasses\"><br/>Arrangement des Classes</h3><p>Maintenant que notre programme contient plusieurs classes/fichiers, nous allons pouvoir utiliser une classification pour structurer nos différentes classes. Ceci s’appelle les packages.</p><p>Vous aurez remarqué, depuis le début, que chaque exemple présenté était préfixé d’une instruction <span style=\"color: rgb(191,38,0);\">package </span>et souvent d’une instruction import. Ces deux mots clés servent à Java pour classifier la classe en cours dans le fichier que vous observez.</p><p>L'instruction package dicte au compilateur où cette classe sera emmagasinée dans l'arbre des classes.</p><p>À l'inverse <span style=\"color: rgb(191,38,0);\">import </span>indique au compilateur que vous voulez utiliser une classe qui se situe à l'extérieur de votre package actuel et vous aimeriez l'utiliser sans avoir à tapper le chemin d'accès complet du package à chaque fois.</p><h2 id=\"JavaInitial-Atelierpratique:conceptionsdeclassesetmiseenrelationentreclasses\"><strong>Atelier pratique : </strong><em><strong>conceptions de classes et mise en relation entre classes</strong></em></h2><h2 id=\"JavaInitial-NotionSpécifiqueauJava\">Notion Spécifique au Java</h2><h3 id=\"JavaInitial-L’encapsulation\">L’encapsulation</h3><p>L'encapsulation consiste à cacher l'état interne d'un objet et d'imposer de passer par des méthodes permettant un accès sécurisé à l'état de l'objet. Pour mettre en oeuvre l'encapsulation, la première étape consiste à privatiser les attributs.</p><p>Cela permet de pouvoir contrôler la valeur d’une propriété. On pourra alors faire une opération spécifique sur celui-ci avant de le set ou avant de la fournir. Par exemple un montant en fonction d’une devise.</p><h3 id=\"JavaInitial-Méthodesàredéfinir\">Méthodes à redéfinir</h3><p><br/>Hash code():</p><p>Dans le <a href=\"https://fr.wikipedia.org/wiki/Langage_de_programmation\" class=\"external-link\" rel=\"nofollow\">langage de programmation</a> <a href=\"https://fr.wikipedia.org/wiki/Java_(langage)\" class=\"external-link\" rel=\"nofollow\">Java</a>, chaque <a href=\"https://fr.wikipedia.org/wiki/Classe_(informatique)\" class=\"external-link\" rel=\"nofollow\">classe</a> doit mettre en œuvre une <a href=\"https://fr.wikipedia.org/wiki/M%C3%A9thode_(informatique)\" class=\"external-link\" rel=\"nofollow\">méthode</a> hashCode() qui digère les données stockées dans une instance de la classe dans une valeur de hachage (en un <a href=\"https://fr.wikipedia.org/wiki/Entier_(informatique)\" class=\"external-link\" rel=\"nofollow\">entier</a> signé 32-<a href=\"https://fr.wikipedia.org/wiki/Bit\" class=\"external-link\" rel=\"nofollow\">bit</a>). Cette valeur de hachage est utilisée par d'autres codes lors du stockage ou de la manipulation de l'instance - les valeurs visent à être réparties de manière homogène pour différentes entrées de manière à être utilisées en <a href=\"https://fr.wikipedia.org/wiki/Table_de_hachage#Choix_d.27une_bonne_fonction_de_hachage\" class=\"external-link\" rel=\"nofollow\">agglomération</a>. Cette propriété est importante pour les performances des <a href=\"https://fr.wikipedia.org/wiki/Table_de_hachage\" class=\"external-link\" rel=\"nofollow\">tables de hachage</a> et autres <a href=\"https://fr.wikipedia.org/wiki/Structure_de_donn%C3%A9es\" class=\"external-link\" rel=\"nofollow\">structures de données</a> qui stockent des objets en groupes (&quot;agglomérats&quot;) en fonction de leurs valeurs de hachage.</p><p>Equals():</p><p>La méthode equals permet à Java de comparer deux objets et de déterminer l’égalité entre ces deux objets, ce qui parait logique. En revanche, beaucoup de personnes oublient que cette méthode est utilisée par la plupart des listes (List, Collection, Vector) pour déterminer la présence ou non d’un objet dans une liste. Cette méthode peut donc être appelée sur chaque élément d’une liste. Il faut donc qu’elle soit optimisée afin d’éviter des problèmes de performance.</p><p><br/>toString():</p><p>La méthode toString est définie dans la classe Object ; en conséquence toutes les classes Java en héritent. La méthode toString définit dans la classe Object ne fait pas grand-chose : elle renvoie le nom de la classe de l'objet concerné suivi de l'adresse de cet objet. Lorsqu'on définit une classe, il peut être très utile de redéfinir la méthode toString afin de donner une description satisfaisante des objets de cette classe.</p><h5 id=\"JavaInitial-LesClassesGeneriques\">Les Classes Generiques</h5><p>Les génériques (de l'anglais <strong>generics</strong>) sont des classes qui sont typées au moment de la compilation. Autrement dit, ce sont des classes qui utilisent des typages en paramètres. Ainsi une liste chainée, qui peut contenir des entiers, des chaînes ou autres, pourra être typée en liste de chaînes ou liste d'entiers, et ceci permettra au programmeur de ne pas écrire systématiquement des transtypages, méthode qui pourrait s'avérer dangereuse, ce sera le compilateur qui vérifiera la cohérence des données.</p><div class=\"code panel pdl conf-macro output-block\" style=\"border-width: 1px;\" data-hasbody=\"true\" data-macro-name=\"code\" data-macro-id=\"9a62e3c4-458b-47fd-9f15-279b4efd9936\"><div class=\"codeContent panelContent pdl\">\n<pre class=\"syntaxhighlighter-pre\" data-syntaxhighlighter-params=\"brush: java; gutter: false; theme: Confluence\" data-theme=\"Confluence\">public class MyList\n{\n\t\n\tprivate LinkedList liste;\n\n\tpublic void setMember(String s)\n\t{\n\t\tliste.add(s);\n\t}\n\tpublic int getMember(int i)\n\t{\n\t\treturn (int)liste.get(i);\n\t}\n}</pre>\n</div></div><div class=\"code panel pdl conf-macro output-block\" style=\"border-width: 1px;\" data-hasbody=\"true\" data-macro-name=\"code\" data-macro-id=\"4143c218-4508-4e9a-a19c-5e7f570d0112\"><div class=\"codeContent panelContent pdl\">\n<pre class=\"syntaxhighlighter-pre\" data-syntaxhighlighter-params=\"brush: java; gutter: false; theme: Confluence\" data-theme=\"Confluence\">/**\n * \n * Utilisation\n * Family&lt;String&gt; family = new Family&lt;String&gt;();\n * family.setMember(&quot;essai&quot;);\n * family.setMember(210);          //seconde erreur\n * \n */\nclass Family &lt; MyClass &gt;\n{\n\tprivate LinkedList &lt; MyClass &gt; list;\n\n\tpublic void setMember(MyClass m)\n\t{\n\t\tlist.add(m);\n\t}\n\n\tpublic MyClass getMember(int i)\n\t{\n\t\treturn list.get(i);\n\t}\n\n\t/*\n\t * public Integer getInt(int i) //première erreur { return liste.get(i); }\n\t */\n}</pre>\n</div></div><h3 id=\"JavaInitial-ReferenceouValeur\">Reference ou Valeur</h3><h4 id=\"JavaInitial-Ilexistedeuxmanièresdetransmettredesargumentsoudesparamètresauxfonctions:\">Il existe deux manières de transmettre des arguments ou des paramètres aux fonctions :</h4><ul><li><p>Passage par valeur</p></li><li><p>Passage par référence</p></li></ul><p>Dans le passage par valeur, une copie des arguments réels est transmise aux arguments formels respectifs. Alors que, dans le passage par référence, l’emplacement (adresse) des arguments réels est transmis à des arguments formels, toute modification apportée aux arguments formels se reflétera également dans les arguments réels.</p><h5 id=\"JavaInitial-Argumentsparréférence\">Arguments par référence</h5><p>Lorsque vous recevez un objet en Java, vous ne recevez pas une copie de cet objet mais bien une référence à cet objet. Vous pouvez donc le modifier et lorsque le contrôle retourne à la fonction précédente, toute modification sera bel et bien conservée.</p><p>Il est important de comprendre ce concept car il est possible d'avoir des effets indésirables lorsqu'on passe nos données à une autre fonction. Normalement, vous devriez vous abstenir de modifier un objet passé en paramètre. C'est considéré comme une mauvaise pratique.</p><h5 id=\"JavaInitial-Argumentsparvaleur\">Arguments par valeur</h5><p><br/>Le contraire d'un argument par référence est un argument par valeur. Tout argument passé en paramètre d'une fonction sera passé par valeur si la variable est de type primitif, par exemple:</p><ul><li><p><span style=\"color: rgb(191,38,0);\">int</span></p></li><li><p><span style=\"color: rgb(191,38,0);\">long</span></p></li><li><p><span style=\"color: rgb(191,38,0);\">float</span></p></li><li><p><span style=\"color: rgb(191,38,0);\">boolean</span></p></li><li><p><span style=\"color: rgb(191,38,0);\">String</span></p></li></ul><p>Si vous tentez de modifier la valeur, vous constaterez qu'au retour de l'appel de fonction, la valeur ne sera pas modifiée!</p><div class=\"confluence-information-macro confluence-information-macro-note conf-macro output-block\" data-hasbody=\"true\" data-macro-name=\"note\" data-macro-id=\"bf8ff32f-eff2-4104-80cd-12495fe67f76\"><span class=\"aui-icon aui-icon-small aui-iconfont-warning confluence-information-macro-icon\"> </span><div class=\"confluence-information-macro-body\"><p>Le <span style=\"color: rgb(191,38,0);\">String</span>, même s'il est considéré comme un type complexe tel un objet, est un cas particulier; lui aussi est passé par valeur.</p></div></div><h3 id=\"JavaInitial-Letranstypage\">Le transtypage</h3><h4 id=\"JavaInitial-Pourlesprimitifs\">Pour les primitifs</h4><div class=\"code panel pdl conf-macro output-block\" style=\"border-width: 1px;\" data-hasbody=\"true\" data-macro-name=\"code\" data-macro-id=\"2370dc31-e5e4-4382-8603-cfa9a226ec4f\"><div class=\"codeContent panelContent pdl\">\n<pre class=\"syntaxhighlighter-pre\" data-syntaxhighlighter-params=\"brush: java; gutter: false; theme: Confluence\" data-theme=\"Confluence\">(nouveau_type)expression</pre>\n</div></div><p>Où <em><span style=\"color: rgb(191,38,0);\">expression</span> </em>est l'expression à convertir. S'il s'agit d'une expression composée, il faut l'encadrer par des parenthèses. La conversion explicite d'une expression doit être utilisée à chaque fois que l'on souhaite convertir une expression dans un type qui n'est pas plus haut dans la hiérarchie des types. Dans le cas des types numériques, cette conversion n'est sans pertes que si le type cible permet de représenter la même valeur. Dans le cas contraire, la valeur choisie dépend du type initial et du type cible. Dans le passage de float à int, la valeur choisie est par exemple la valeur entière de la valeur initiale :</p><div class=\"code panel pdl conf-macro output-block\" style=\"border-width: 1px;\" data-hasbody=\"true\" data-macro-name=\"code\" data-macro-id=\"12db9929-af0c-423f-87b9-d9255f4c956d\"><div class=\"codeContent panelContent pdl\">\n<pre class=\"syntaxhighlighter-pre\" data-syntaxhighlighter-params=\"brush: java; gutter: false; theme: Confluence\" data-theme=\"Confluence\">int n;\nfloat f;\n\nn = 3;\nf = n;        // f vaut 3.0\nf = f + 1;    // conversion de 1 en 1.0 et somme : f vaut 4.0\nn = (int) f;  // n vaut 4\nf = f + 1.5;  // f passe à 5.5\nn = (int) f;  // 5.5 est arrondi en 5 : n vaut 5.</pre>\n</div></div><h4 id=\"JavaInitial-Parréférence\">Par référence</h4><p>Pour les types de références, la conversion est libre : une référence de type quelconque peut être explicitement convertie en toute référence dont le type permet de manipuler l'objet référencé, selon les règles ci-dessus. La non-validité de cette conversion n'est en général pas détectable avant l'exécution :</p><div class=\"code panel pdl conf-macro output-block\" style=\"border-width: 1px;\" data-hasbody=\"true\" data-macro-name=\"code\" data-macro-id=\"ce2249e2-6ecf-458f-a36c-3c52600ff98a\"><div class=\"codeContent panelContent pdl\">\n<pre class=\"syntaxhighlighter-pre\" data-syntaxhighlighter-params=\"brush: java; gutter: false; theme: Confluence\" data-theme=\"Confluence\">interface I { ... }\nclass A { ... }\nclass B extends A implements I { ... } \nclass C { ... }\n ...\nObject o = new B(); // l'objet créé est de classe B\nI i = (I) o;  // valide : B implémente I\nA a = (A) o;  // valide : A est ancêtre de B\nB b = (B) a;  // valide\nC c = (C) o;  // invalide : C n'est pas ancêtre de B</pre>\n</div></div><p>Ces conversions &quot;descendantes&quot; sont bien sûr propices aux erreurs. L'opérateur instanceof permet de vérifier la validité d'une conversion avant de l'effectuer :</p><div class=\"code panel pdl conf-macro output-block\" style=\"border-width: 1px;\" data-hasbody=\"true\" data-macro-name=\"code\" data-macro-id=\"0e5384cb-4e56-4132-ba59-e1447a213695\"><div class=\"codeContent panelContent pdl\">\n<pre class=\"syntaxhighlighter-pre\" data-syntaxhighlighter-params=\"brush: java; gutter: false; theme: Confluence\" data-theme=\"Confluence\">if (r instanceof C) {\n  c = (C) r;\n  // action sur les instances de C\n  ...\n}\nelse {\n  // action sur les instances d'une autre classe\n  ...\n}</pre>\n</div></div><h3 id=\"JavaInitial-Lesclassesdeconstantes\">Les classes de constantes</h3><h4 id=\"JavaInitial-Définition.5\">Définition</h4><p>Souvent lors de l'écriture de code, il est utile de pouvoir définir un ensemble fini de valeurs d'une donnée ; par exemple, pour définir les valeurs possibles qui vont caractériser l'état de cette donnée.</p><p>Pour cela, le type énumération permet de définir un ensemble de constantes : une énumération est un ensemble fini d'éléments constants. Cette fonctionnalité existe déjà dans les langages C et Delphi, entre autres.</p><p>Jusqu'à la version 1.4 incluse, la façon la plus pratique pour pallier le manque du type enum était de créer des constantes dans une classe.</p><div class=\"code panel pdl conf-macro output-block\" style=\"border-width: 1px;\" data-hasbody=\"true\" data-macro-name=\"code\" data-macro-id=\"726b3495-a3a2-44e2-928e-cc5ded359685\"><div class=\"codeContent panelContent pdl\">\n<pre class=\"syntaxhighlighter-pre\" data-syntaxhighlighter-params=\"brush: java; gutter: false; theme: Confluence\" data-theme=\"Confluence\">public enum Gender {\n\tMALE,\n\tFEMALE,\n\tOTHER\n}</pre>\n</div></div><h4 id=\"JavaInitial-Inconvenients\">Inconvenients</h4><p>Cette approche fonctionne : les constantes peuvent être sérialisées et utilisées dans une instruction switch mais leur mise en oeuvre n'est pas type safe. Rien n'empêche d'affecter une autre valeur à la donnée de type int qui va stocker une des valeurs constantes.</p><p>A défaut, cette solution permet de répondre au besoin mais elle présente cependant quelques inconvénients:</p><ul><li><p>le principal inconvénient de cette technique est qu'il n'y a pas de contrôle sur la valeur affectée à une donnée surtout si les constantes ne sont pas utilisées : il est possible d'utiliser n'importe quelle valeur permise par le type de la variable en plus des constantes définies. Le compilateur ne peut faire aucun contrôle sur les valeurs utilisées</p></li><li><p>il n'est pas possible de faire une itération sur chacune des valeurs</p></li><li><p>il n'est pas possible d'associer des traitements à une constante</p></li><li><p>les modifications faites dans ces constantes notamment les changements de valeurs ne sont pas automatiquement reportées dans les autres classes qui doivent être explicitement recompilées</p></li></ul><h3 id=\"JavaInitial-LesEnums\">Les Enums</h3><p>La définition d'une énumération ressemble à celle d'une classe avec quelques différences :</p><ul><li><p>utilisation du mot clé enum introduit spécifiquement dans ce but à la place du mot clé class</p></li><li><p>un ensemble de valeurs constantes définies au début du corps de la définition, chaque valeur étant séparée par une virgule</p></li><li><p>par convention le nom des constantes est en majuscule</p></li></ul><p>Une énumération peut prendre plusieurs formes et être enrichie de fonctionnalités puisqu'une énumération est une classe Java.</p><p>Dans sa forme la plus simple, la déclaration d'une énumération se résume à définir l'ensemble des constantes.</p><h3 id=\"JavaInitial-Stream&amp;Lambda\">Stream &amp; Lambda<br/></h3><p>Stream:</p><p>Le concept de Stream existe déjà depuis longtemps dans l'API I/O, notamment avec les interfaces InputStream et OutputStream. Il ne faut pas confondre l'API Stream de Java 8 avec les classes de type xxxStream de Java I/O. Les streams de Java I/O permettent de lire ou écrire des données dans un flux (sockets, fichiers, ...). Le concept de Stream de Java 8 est différent du concept de flux (stream) de l'API I/O même si l'approche de base est similaire : manipuler un flux d'octets ou de caractères pour l'API I/O et manipuler un flux de données pour l'API Stream. Cette dernière repose sur le concept de flux (stream en anglais) qui est une séquence d'éléments.</p><p>Lambda:</p><p>Les expressions lambda ont été intégrées en Java 8. Elles sont la première étape de la programmation fonctionnelle. Une expression lambda est un fonction définie à la volée pour un besoin ponctuel relayé à aucune classe. Les expressions lambda peuvent être passées comme un objet et exécutées à la demande.</p><p>Elles sont utilisées principalement pour implementer des listeners d'événement/callbacks ou dans la programmation fonctionnelle.</p><h1 id=\"JavaInitial-ExceptionsdanslelangageJava\"><strong>Exceptions dans le langage Java</strong></h1><h2 id=\"JavaInitial-Principed’uneexception\"><strong>Principe d’une exception</strong></h2><h3 id=\"JavaInitial-Définition.6\">Définition</h3><p>Les exceptions représentent le mécanisme de gestion des erreurs intégré au langage Java. Il se compose d'objets représentant les erreurs et d'un ensemble de trois mots clés qui permettent de détecter et de traiter ces erreurs (try, catch et finally ) mais aussi de les lever ou les propager (throw et throws).</p><p>Lors de la détection d'une erreur, un objet qui hérite de la classe Exception est créé (on dit qu'une exception est levée) et propagé à travers la pile d'exécutions jusqu'à ce qu'il soit traité.</p><p>Ces mécanismes permettent de renforcer la sécurité du code Java.</p><p /><span class=\"confluence-embedded-file-wrapper image-center-wrapper\"><img class=\"confluence-embedded-image image-center\" loading=\"lazy\" src=\"https://computhand.atlassian.net/wiki/download/attachments/153485313/zwl59gdOugDJwELVezxswgQ9_RsJgib--vouBdE1Lq0YnQ2lPwK-shkEYBCjk8_7F7vvGDieU-CQ30TqZzmScSnq8UJrHKziNDgX7tLwM7Q7-jaOP08S294P6_LMui0L_X164Poua8c?version=1&amp;modificationDate=1590033381687&amp;cacheVersion=1&amp;api=v2\" data-image-src=\"https://computhand.atlassian.net/wiki/download/attachments/153485313/zwl59gdOugDJwELVezxswgQ9_RsJgib--vouBdE1Lq0YnQ2lPwK-shkEYBCjk8_7F7vvGDieU-CQ30TqZzmScSnq8UJrHKziNDgX7tLwM7Q7-jaOP08S294P6_LMui0L_X164Poua8c?version=1&amp;modificationDate=1590033381687&amp;cacheVersion=1&amp;api=v2\" data-height=\"218\" data-width=\"642\" data-unresolved-comment-count=\"0\" data-linked-resource-id=\"191627398\" data-linked-resource-version=\"1\" data-linked-resource-type=\"attachment\" data-linked-resource-default-alias=\"zwl59gdOugDJwELVezxswgQ9_RsJgib--vouBdE1Lq0YnQ2lPwK-shkEYBCjk8_7F7vvGDieU-CQ30TqZzmScSnq8UJrHKziNDgX7tLwM7Q7-jaOP08S294P6_LMui0L_X164Poua8c\" data-base-url=\"https://computhand.atlassian.net/wiki\" data-linked-resource-content-type=\"image/png\" data-linked-resource-container-id=\"153485313\" data-linked-resource-container-version=\"17\" data-media-id=\"4fd186c3-9cd1-43b0-afcf-57632fcf6b0f\" data-media-type=\"file\"></span><h3 id=\"JavaInitial-Lestypesd’Exception\">Les types d’Exception</h3><h4 id=\"JavaInitial-RuntimeException(uncheckedException):\">RuntimeException(unchecked Exception):</h4><p>Ce sont des exceptions qui ne sont pas vérifiées à la compilation et qui peuvent être généralement éviter de façon programmatique. (ex: NullPointerException, ArrayIndexOutOfBoundException,...). On les appelle également RuntimeException car elles héritent de la classe RuntimeException</p><h4 id=\"JavaInitial-CheckedException:\">Checked Exception:</h4><p>Ces exceptions ne peuvent être éviter, elles nécessitent obligatoirement un bloc try{}catch ou d'être lever(throw)</p><p>(ex: IOException)</p><h2 id=\"JavaInitial-Manipulerdesexceptions\"><strong>Manipuler des exceptions</strong></h2><p><strong>Une exception peut être gérée de 2 façons:</strong></p><h3 id=\"JavaInitial-Propagation:\"><strong>Propagation:</strong> </h3><p>le mot clé <span style=\"color: rgb(191,38,0);\">throw </span>permet de lever une exception. On indiquera donc au niveau de la méthode <span style=\"color: rgb(191,38,0);\">throws </span>suivi du type d’Exception que celle-ci fera suivre. Cela permettra à l’appelant de savoir quoi gérer comme type d’exception. En voici la syntaxe:</p><h3 id=\"JavaInitial-Traitement:\"><strong>Traitement:</strong></h3><p>Si un événement indésirable survient dans le bloc try, la partie éventuellement non exécutée de ce bloc est abandonnée et le premier bloc catch est traité. Si un bloc catch est défini pour capturer l'exception issue du bloc try alors elle est traitée en exécutant le code associé au bloc. Si le bloc catch est vide (aucune instruction entre les accolades) alors l'exception capturée est ignorée. Une telle utilisation de l'instruction try/catch n'est pas une bonne pratique : il est préférable de toujours apporter un traitement adapté lors de la capture d'une exception.</p><p>S'il y a plusieurs types d'erreurs et d'exceptions à intercepter, il faut définir autant de blocs catch que de types d'événements. Par type d'exception, il faut comprendre « qui est du type de la classe de l'exception ou d'une de ses sous-classes ». Ainsi dans l'ordre séquentiel des clauses catch, un type d'exception ne doit pas venir après un type d'une exception d'une super-classe. Il faut faire attention à l'ordre des clauses catch pour traiter en premier les exceptions </p><p>les plus précises (sous-classes) avant les exceptions plus générales. </p><p>Un message d'erreur est émis par le compilateur dans le cas contraire.</p><div class=\"code panel pdl conf-macro output-block\" style=\"border-width: 1px;\" data-hasbody=\"true\" data-macro-name=\"code\" data-macro-id=\"bbd7fa9d-cb70-4cfe-aa4e-0be3a08d7cbe\"><div class=\"codeContent panelContent pdl\">\n<pre class=\"syntaxhighlighter-pre\" data-syntaxhighlighter-params=\"brush: java; gutter: false; theme: Confluence\" data-theme=\"Confluence\">\t\ttry {\n\t\t\tcontrol(string1);\n\t\t} catch (ErrorEntryException e) {\n\t\t\tSystem.out.println(&quot;Chaine2 saisie erronee&quot;);\n\t\t}finally {\n\t\t\t\n\t\t}\n\t\t\n\t\ttry {\n\t\t\tcontrol(string2);\n\t\t} catch (ErrorEntryException e) {\n\t\t\tLOG.severe(&quot;Chaine2 saisie erronee&quot;);\n\t\t}catch(Exception npe) {\n\t\t\n\t\t}finally {\n\t\t\t\n\t\t}</pre>\n</div></div><div class=\"confluence-information-macro confluence-information-macro-note conf-macro output-block\" data-hasbody=\"true\" data-macro-name=\"note\" data-macro-id=\"efa9b4af-9a5c-4bc5-9d30-ce726d2dae77\"><span class=\"aui-icon aui-icon-small aui-iconfont-warning confluence-information-macro-icon\"> </span><div class=\"confluence-information-macro-body\"><p>Il peut y avoir plusieurs blocs de catch pour attraper plusieurs exceptions, il faudra cependant ordonner les blocs de l’exception la plus spécifique à la plus générique.</p></div></div><p><span style=\"color: rgb(191,38,0);\">finally</span><span style=\"color: rgb(255,255,255);\">:</span></p><p>On pourra mettre un bloc finally si on veut qu’une partie du code s'exécute qu’il y ait une exécution ou non. Par la fermeture d’un fichier même s’il y a eu une erreur dans sa lecture.</p><p><strong>Utilisation des deux méthodes:</strong></p><p>Ces deux méthodes peuvent être utilisées simultanément on peut lever une exception dans un bloc catch pour faire de la gestion globale d’exception et ne remonter qu’une exception générique ou ne donner qu’un seul message à l’appelant.</p><h1 id=\"JavaInitial-Collections\"><strong>Collections</strong></h1><h2 id=\"JavaInitial-Présentationdescollections\"><strong>Présentation des collections</strong></h2><p>Qu'arrive-t-il si vous voulez travailler avec plus de données ou bien avec un nombre inconnu de données? Les tableaux ne vous seront pas très utiles à ce moment-là. Voici donc les collections. Il existe beaucoup de collections différentes en Java mais nous n'en verrons que 2 ici.</p><p>Les collections sont un genre de tableau super chargé qui permet de stocker un nombre illimité d'informations.</p><p>Nous pourrons reprendre la définition des classes <span style=\"color: rgb(191,38,0);\">generics </span>que nous avons vu.</p><p>L'API Collections propose un ensemble d'interfaces et de classes dont le but est de stocker de multiples objets. Elle propose quatre grandes familles de collections, chacune définie par une interface de base :</p><ul><li><p>List : collection d'éléments ordonnés qui accepte les doublons</p></li><li><p>Set : collection d'éléments non ordonnés par défaut qui n'accepte pas les doublons</p></li><li><p>Map : collection sous la forme d'une association de paires clé/valeur</p></li><li><p>Queue: collections qui stockent des éléments dans un certain ordre avant qu'ils ne soient extraits pour traitement</p></li></ul><h3 id=\"JavaInitial-CollectiondetypeList\">Collection de type List</h3><p>Une collection de type List est une collection simple et ordonnée d'éléments qui autorise les doublons. La liste étant ordonnée, un élément peut être accédé à partir de son index.</p><p>L’interface List étend l'interface Collection.</p><p>Une collection de type List permet :</p><ul><li><p>de contenir des doublons</p></li><li><p>d'interagir avec un élément de la collection en utilisant sa position</p></li></ul><p>d'insérer des éléments <span style=\"color: rgb(191,38,0);\">null</span></p><h3 id=\"JavaInitial-CollectiondetypeSet\">Collection de type Set</h3><p>Une collection de type Set ne permet pas l'ajout de doublons ni l'accès direct à un élément de la collection. Les fonctionnalités de base de ce type de collection sont définies dans l'interface <span style=\"color: rgb(191,38,0);\">java.util.Set</span>.</p><p>L'interface Set définit les fonctionnalités d'une collection qui ne peut pas contenir de doublons dans ses éléments.</p><p>Les éléments ajoutés dans une collection de type Set doivent réimplémenter leurs méthodes <span style=\"color: rgb(191,38,0);\">equals()</span> et <span style=\"color: rgb(191,38,0);\">hashCode()</span>. Ces méthodes sont utilisées lors de l'ajout d'un élément pour déterminer s'il est déjà présent dans la collection. La valeur retournée par <span style=\"color: rgb(191,38,0);\">hashCode()</span> est recherchée dans la collection :</p><ul><li><p>si aucun objet de la collection n'a la même valeur de hachage alors l'objet n'est pas encore dans la collection et peut être ajouté</p></li><li><p>si un ou plusieurs objets de la collection ont la même valeur de hachage alors la méthode equals() de l'objet à ajouter est invoquée sur chacun des objets pour déterminer si l'objet est déjà présent ou non dans la collection</p></li></ul><h3 id=\"JavaInitial-CollectiondeMap\">Collection de Map</h3><p>Les collections de type Map sont définies et implémentées comme des dictionnaires sous la forme d'associations de paires de type clés/valeurs. La clé doit être unique. En revanche, la même valeur peut être associée à plusieurs clés différentes.</p><p>Avant l'apparition du framework Collections, la classe dédiée à cette gestion était la classe Hashtable.</p><p>Un objet de type Map permet de lier un objet avec une clé qui peut être un type primitif ou un autre objet. Il est ainsi possible d'obtenir un objet à partir de sa clé.</p><h3 id=\"JavaInitial-CollectiondetypeQueue\">Collection de type Queue</h3><p>Une Queue est une collection qui stocke des éléments dans un certain ordre avant d'être consommés pour être traités.</p><p>La plupart des implémentations proposées par le framework Collection utilise l'ordre FIFO (First In, First Out) mais l'ordre peut être différent.</p><p>La majorité des implémentations sont dans le package java.util.concurrent</p><p>L'interface Queue définit les fonctionnalités pour une file d'objets (une collection qui permet de stocker des éléments avant leur traitement).</p><p>Une file propose trois opérations standard :</p><ul><li><p>ajouter un élément</p></li><li><p>obtenir un élément</p></li><li><p>consulter le prochain élément disponible : cette opération ne le retire pas de la collection</p></li></ul><p>L'interface Queue propose des méthodes pour deux comportements différents en cas d'échec de ses opérations par exemple si la collection est vide ou pleine : le renvoi d'un booléen qui indique le succès de l'opération ou la levée d'une exception.<br/></p><h3 id=\"JavaInitial-LesCollectionslesplusutilisées\">Les Collections les plus utilisées</h3><h4 id=\"JavaInitial-ArrayList\">ArrayList</h4><p>L'ArrayList est une collection spéciale qui permet de stocker autant d'éléments que vous le souhaitez en mémoire de la même façon qu'un tableau. Vous accédez à un élément en utilisant un index et l'ArrayList s'occupe de gérer la mémoire associée avec celui-ci.</p><div class=\"code panel pdl conf-macro output-block\" style=\"border-width: 1px;\" data-hasbody=\"true\" data-macro-name=\"code\" data-macro-id=\"29f0150c-0f4b-46a9-8c49-147527c4835f\"><div class=\"codeContent panelContent pdl\">\n<pre class=\"syntaxhighlighter-pre\" data-syntaxhighlighter-params=\"brush: java; gutter: false; theme: Confluence\" data-theme=\"Confluence\">import java.util.ArrayList;\n\n//some class implementation\nArrayList myList = new ArrayList();\nmyList.add(&quot;Mathieu&quot;);\nmyList.add(&quot;Julie&quot;);\nmyList.add(&quot;Patrick&quot;);</pre>\n</div></div><p>Vous avez l'équivalent d'un tableau mais vous pouvez ajouter autant d'informations que vous le voulez à cette liste. Aucun besoin de savoir la taille à l'avance!</p><p>Pour accéder à un élément de la liste, il faut utiliser la fonction<span style=\"color: rgb(255,255,255);\"> </span><span style=\"color: rgb(191,38,0);\">get</span>:</p><div class=\"code panel pdl conf-macro output-block\" style=\"border-width: 1px;\" data-hasbody=\"true\" data-macro-name=\"code\" data-macro-id=\"db323e60-2cc4-473a-91f0-a831d9c5a4a9\"><div class=\"codeContent panelContent pdl\">\n<pre class=\"syntaxhighlighter-pre\" data-syntaxhighlighter-params=\"brush: java; gutter: false; theme: Confluence\" data-theme=\"Confluence\">System.out.println(maListe.get(0));\nSystem.out.println(maListe.get(1));\nSystem.out.println(maListe.get(2));</pre>\n</div></div><p>Et si vous souhaitez obtenir la taille de la collection, utilisez <span style=\"color: rgb(191,38,0);\">size</span>:</p><div class=\"code panel pdl conf-macro output-block\" style=\"border-width: 1px;\" data-hasbody=\"true\" data-macro-name=\"code\" data-macro-id=\"ae5c2640-83b0-44e7-9b4d-81b048d56d15\"><div class=\"codeContent panelContent pdl\">\n<pre class=\"syntaxhighlighter-pre\" data-syntaxhighlighter-params=\"brush: java; gutter: false; theme: Confluence\" data-theme=\"Confluence\">System.out.println(maListe.size());</pre>\n</div></div><div class=\"confluence-information-macro confluence-information-macro-note conf-macro output-block\" data-hasbody=\"true\" data-macro-name=\"note\" data-macro-id=\"5e04a107-f2e0-47b0-adfb-29b479750629\"><span class=\"aui-icon aui-icon-small aui-iconfont-warning confluence-information-macro-icon\"> </span><div class=\"confluence-information-macro-body\"><p>Il est à noter qu'une collection utilise beaucoup plus de mémoire et est moins optimisée qu'un tableau. Selon les opérations à exécuter, il est souhaitable d'utiliser plutôt un tableau qu'une collection.</p></div></div><h4 id=\"JavaInitial-ArrayListgénérique\">ArrayList générique</h4><p>Lorsque vous définissez une ArrayList sans sous-type précis, vous recevez une collection non typée qui peut accepter n'importe quelle information. Par exemple:</p><div class=\"code panel pdl conf-macro output-block\" style=\"border-width: 1px;\" data-hasbody=\"true\" data-macro-name=\"code\" data-macro-id=\"7de9def4-2188-4866-84c1-ae9aabc5def6\"><div class=\"codeContent panelContent pdl\">\n<pre class=\"syntaxhighlighter-pre\" data-syntaxhighlighter-params=\"brush: java; gutter: false; theme: Confluence\" data-theme=\"Confluence\">import java.util.ArrayList;\n\n//some class implementation\nArrayList myList = new ArrayList();\nmyList.add(&quot;Mathieu&quot;);\nmyList.add(10);\nmyList.add(true);</pre>\n</div></div><p>Vous n'aurez aucune erreur si vous lancez cet exemple manuellement car la liste n'est pas typée! Si vous voulez contrôler les données acceptées par une ArrayList, vous devez lui donner un type. Voici un exemple d'une ArrayList typée à l'aide de la fonction <span style=\"color: rgb(191,38,0);\">generics </span>de Java:</p><div class=\"code panel pdl conf-macro output-block\" style=\"border-width: 1px;\" data-hasbody=\"true\" data-macro-name=\"code\" data-macro-id=\"72bc83f9-f113-4c3f-b545-2d84b22348e6\"><div class=\"codeContent panelContent pdl\">\n<pre class=\"syntaxhighlighter-pre\" data-syntaxhighlighter-params=\"brush: java; gutter: false; theme: Confluence\" data-theme=\"Confluence\">import java.util.ArrayList;\n\n//some class implementation\nArrayList&lt;Integer&gt; myListeOfInt = new ArrayList&lt;Integer&gt;();\nmyListeOfInt .add(1);\nmyListeOfInt .add(10);\nmyListeOfInt .add(1.5); // &lt;- Erreur, ceci est un float\nmyListeOfInt .add(&quot;Mathieu&quot;); // &lt;- Erreur, ceci est une String</pre>\n</div></div><h4 id=\"JavaInitial-HashMap\">HashMap</h4><p>Le Hashmap est une collection qui permet de retrouver n'importe quelle information en utilisant une clef. Par exemple, vous souhaitez retrouver une ville basée sur son code plutôt que son nom? Créez alors un HashMap qui utilise comme clef un <span style=\"color: rgb(191,38,0);\">String</span>. Vous pouvez ensuite utiliser <span style=\"color: rgb(191,38,0);\">get()</span> comme pour le <span style=\"color: rgb(191,38,0);\">ArrayList </span>mais avec un <span style=\"color: rgb(191,38,0);\">String </span>pour la retrouver facilement. Par exemple:</p><div class=\"code panel pdl conf-macro output-block\" style=\"border-width: 1px;\" data-hasbody=\"true\" data-macro-name=\"code\" data-macro-id=\"34f9691b-2c7b-4f1e-8f87-4c6ad9664ad9\"><div class=\"codeContent panelContent pdl\">\n<pre class=\"syntaxhighlighter-pre\" data-syntaxhighlighter-params=\"brush: java; gutter: false; theme: Confluence\" data-theme=\"Confluence\">import java.util.HashMap;\n\n//some class implementation\nHashMap&lt;String, String&gt; myMap = new HashMap&lt;String, String&gt;();\nmyMap.add(&quot;Mathieu&quot;, &quot;Mathieu Dumoulin&quot;);\nmyMap.add(&quot;Julie&quot;, &quot;Julie Tremblay&quot;);\nmyMap.add(&quot;Patrick&quot;, &quot;Patrick Savard&quot;);</pre>\n</div></div><p>Vous avez l'équivalent d'un tableau mais vous pouvez ajouter autant d'information que vous le voulez à cette liste et plus besoin de retrouver l'information manuellement.</p><p>Pour accéder à un élément de la liste, il faut utiliser la fonction <span style=\"color: rgb(191,38,0);\">get</span>:</p><div class=\"code panel pdl conf-macro output-block\" style=\"border-width: 1px;\" data-hasbody=\"true\" data-macro-name=\"code\" data-macro-id=\"c89255ab-9559-493c-ab96-78c37212a132\"><div class=\"codeContent panelContent pdl\">\n<pre class=\"syntaxhighlighter-pre\" data-syntaxhighlighter-params=\"brush: java; gutter: false; theme: Confluence\" data-theme=\"Confluence\">System.out.println(myMap.get(&quot;Mathieu&quot;));\nSystem.out.println(myMap.get(&quot;Julie&quot;));\nSystem.out.println(myMap.get(&quot;Patrick&quot;));</pre>\n</div></div><p>Si vous souhaitez obtenir la taille de la collection, utilisez <span style=\"color: rgb(191,38,0);\">size</span>:</p><div class=\"code panel pdl conf-macro output-block\" style=\"border-width: 1px;\" data-hasbody=\"true\" data-macro-name=\"code\" data-macro-id=\"3335ab70-e21e-46f8-bfcc-47cf892a21af\"><div class=\"codeContent panelContent pdl\">\n<pre class=\"syntaxhighlighter-pre\" data-syntaxhighlighter-params=\"brush: java; gutter: false; theme: Confluence\" data-theme=\"Confluence\">System.out.println(myMap.size());</pre>\n</div></div><p>Finalement, si vous souhaitez vérifier l'existence d'une clef, utilisez <span style=\"color: rgb(191,38,0);\">containsKey</span>:</p><div class=\"code panel pdl conf-macro output-block\" style=\"border-width: 1px;\" data-hasbody=\"true\" data-macro-name=\"code\" data-macro-id=\"1301a330-0a56-437b-8eb7-1a9b4017423f\"><div class=\"codeContent panelContent pdl\">\n<pre class=\"syntaxhighlighter-pre\" data-syntaxhighlighter-params=\"brush: java; gutter: false; theme: Confluence\" data-theme=\"Confluence\">if (myMap.containsKey(&quot;Mathieu&quot;)) {\n    System.out.println(&quot;Cette clef existe déjà&quot;);\n}</pre>\n</div></div><h2 id=\"JavaInitial-Itérersurdescollections\"><strong>Itérer sur des collections</strong></h2><h3 id=\"JavaInitial-BoucledetypeforeachpourunArrayList\">Boucle de type for each pour un ArrayList</h3><p>Lorsque vous utilisez des collections, vous aurez tendance à vouloir regarder chaque élément d'une collection afin d'y apporter des changements ou bien pour afficher son contenu. Pour se faire, vous pouvez utiliser un type de boucle spécial que nous n'avons pas vu jusqu'à présent: la boucle for each.</p><p>La boucle for each est une légère variation de la boucle <span style=\"color: rgb(191,38,0);\">for </span>qui est très simple à utiliser. En voici un exemple:</p><div class=\"code panel pdl conf-macro output-block\" style=\"border-width: 1px;\" data-hasbody=\"true\" data-macro-name=\"code\" data-macro-id=\"149335f6-673d-418e-9da0-3d26dd17d7f6\"><div class=\"codeContent panelContent pdl\">\n<pre class=\"syntaxhighlighter-pre\" data-syntaxhighlighter-params=\"brush: java; gutter: false; theme: Confluence\" data-theme=\"Confluence\">ArrayList&lt;String&gt; namesList= new ArrayList&lt;String&gt;();\n\nnamesList.add(&quot;Mathieu&quot;);\nnamesList.add(&quot;Julie&quot;);\nnamesList.add(&quot;Zachary&quot;);\n\nfor (String name : namesList) {\n    System.out.println(name);\n}</pre>\n</div></div><p>Ici, nous créons une <span style=\"color: rgb(191,38,0);\">ArrayList </span>de type <span style=\"color: rgb(191,38,0);\">String </span>avec trois noms et utilisons ensuite l'instruction <span style=\"color: rgb(191,38,0);\">for </span>avec une structure différente. Le type vient en premier, le nom de la variable qui recevra chaque élément de la liste sera ensuite utilisé et finalement, l'opérateur <span style=\"color: rgb(191,38,0);\">:</span> et le nom de la collection seront ajoutés.</p><p>Ceci exécutera une boucle telle que précédemment étudiée. Chaque élément de la liste sera bouclé et passé à la variable <span style=\"color: rgb(191,38,0);\">name </span>jusqu'à la fin de la liste. Ensuite la boucle se terminera automatiquement.</p><h3 id=\"JavaInitial-BoucleforeachpouruneHashMap\">Boucle for each pour une HashMap</h3><p>Lorsque vous utilisez un for each pour un <span style=\"color: rgb(191,38,0);\">HashMap</span>, vous ne pouvez pas directement utiliser le for each sur la collection. Du moins, si vous le faites, vous n'aurez pas les données comme vous l'espériez. Voici un exemple:</p><div class=\"code panel pdl conf-macro output-block\" style=\"border-width: 1px;\" data-hasbody=\"true\" data-macro-name=\"code\" data-macro-id=\"bf8535e2-18a8-438c-bc8d-e08f5466d65a\"><div class=\"codeContent panelContent pdl\">\n<pre class=\"syntaxhighlighter-pre\" data-syntaxhighlighter-params=\"brush: java; gutter: false; theme: Confluence\" data-theme=\"Confluence\">HashMap&lt;String, String&gt; villes = new HashMap&lt;String, String&gt;();\nvilles.put(&quot;YUL&quot;, &quot;Montréal&quot;);\nvilles.put(&quot;ORD&quot;, &quot;Chicago&quot;);\nvilles.put(&quot;MEX&quot;, &quot;Mexico city&quot;);\n\nfor (String code : villes.keySet()) {\n    System.out.println(String.format(&quot;La ville %s à le code %s&quot;,  villes.get(code), code));\n}</pre>\n</div></div><p>Ici, nous utilisons la fonction <span style=\"color: rgb(191,38,0);\">keySet()</span> du <span style=\"color: rgb(191,38,0);\">HashMap </span>pour retourner les clefs du <span style=\"color: rgb(191,38,0);\">HashMap</span>. Ceci permet d'avoir accès à la clef et donc aussi, en même temps aux données en utilisant la fonction <span style=\"color: rgb(191,38,0);\">get()</span>. Par contre, cette approche demande d'utiliser deux opérations sur la liste pour obtenir toutes nos informations. Voici comment faire pour obtenir toutes les informations:</p><div class=\"code panel pdl conf-macro output-block\" style=\"border-width: 1px;\" data-hasbody=\"true\" data-macro-name=\"code\" data-macro-id=\"e8d4f9f7-4667-4dc4-8cca-f21c6e47af63\"><div class=\"codeContent panelContent pdl\">\n<pre class=\"syntaxhighlighter-pre\" data-syntaxhighlighter-params=\"brush: java; gutter: false; theme: Confluence\" data-theme=\"Confluence\">import java.map.Entry;\n\nHashMap&lt;String, String&gt; citiesList = new HashMap&lt;String, String&gt;();\ncitiesList.put(&quot;YUL&quot;, &quot;Montréal&quot;);\ncitiesList.put(&quot;ORD&quot;, &quot;Chicago&quot;);\ncitiesList.put(&quot;MEX&quot;, &quot;Mexico city&quot;);\n\nfor (Entry&lt;String, String&gt; city: citiesList.entrySet()) {\n    System.out.println(String.format(&quot;La ville %s à le code %s&quot;,  city.getValue(), city.getKey()));\n}</pre>\n</div></div><p>Cette subtile différence est plus longue à écrire et demande un <span style=\"color: rgb(191,38,0);\">import </span>additionnel: l'<span style=\"color: rgb(191,38,0);\">Entry</span>. Par contre, cette approche élimine le besoin d'obtenir la clef et l'élément en deux temps. Dans un programme où vous aurez à traiter une quantité d'information colossale, cette petite différence peut avoir un très grand impact.</p><p>Si vous n'avez jamais besoin de la clef alors l'ultime option est d'utiliser <span style=\"color: rgb(191,38,0);\">values()</span> qui retourne tout simplement une collection des valeurs emmagasinées dans le <span style=\"color: rgb(191,38,0);\">HashMap</span>. Par exemple:</p><div class=\"code panel pdl conf-macro output-block\" style=\"border-width: 1px;\" data-hasbody=\"true\" data-macro-name=\"code\" data-macro-id=\"1c08f3f4-e79a-411c-b431-23e1139a2595\"><div class=\"codeContent panelContent pdl\">\n<pre class=\"syntaxhighlighter-pre\" data-syntaxhighlighter-params=\"brush: java; gutter: false; theme: Confluence\" data-theme=\"Confluence\">HashMap&lt;String, String&gt; citiesList = new HashMap&lt;String, String&gt;();\ncitiesList.put(&quot;YUL&quot;, &quot;Montréal&quot;);\ncitiesList.put(&quot;ORD&quot;, &quot;Chicago&quot;);\ncitiesList.put(&quot;MEX&quot;, &quot;Mexico city&quot;);\n\nfor (String city: citiesList.values()) {\n    System.out.println(String.format(&quot;Trouvé la ville %s&quot;,  city));\n}</pre>\n</div></div><h3 id=\"JavaInitial-Tridanslescollections\">Tri dans les collections</h3><h4 id=\"JavaInitial-Comparable\">Comparable</h4><p>Tous les objets qui doivent définir un ordre naturel utilisé par le tri d'une collection doivent implémenter cette interface.</p><p>Cette interface ne définit qu'une seule méthode : int compareTo(Object).</p><p>Cette méthode doit renvoyer :</p><ul><li><p>une valeur entière négative si l'objet courant est inférieur à l'objet fourni</p></li><li><p>une valeur entière positive si l'objet courant est supérieur à l'objet fourni</p></li><li><p>une valeur nulle si l'objet courant est égal à l'objet fourni</p></li></ul><p>Les classes wrappers, String et Date implémentent cette interface.</p><div class=\"code panel pdl conf-macro output-block\" style=\"border-width: 1px;\" data-hasbody=\"true\" data-macro-name=\"code\" data-macro-id=\"07c9755f-f46c-4835-8678-6b3c107d8b0c\"><div class=\"codeContent panelContent pdl\">\n<pre class=\"syntaxhighlighter-pre\" data-syntaxhighlighter-params=\"brush: java; gutter: false; theme: Confluence\" data-theme=\"Confluence\">public class Person implements Comparable&lt;Person&gt; {\n\t\n\tprivate String firstName;\n\t\n\tprivate String lastName;\n\t\tpublic String getFirstName() {\n\t\treturn firstName;\n\t}\n\n\tpublic void setFirstName(String firstName) {\n\t\tthis.firstName = firstName;\n\t}\n\n\tpublic String getLastName() {\n\t\treturn lastName;\n\t}\n\n\tpublic void setLastName(String lastName) {\n\t\tthis.lastName = lastName;\n\t}\n\t\n\t@Override\n\tpublic int compareTo(Person s) {\n\t\tif (!this.getLastName().equals(s.getLastName()))\n\t\t\treturn this.getLastName().compareTo(s.getLastName());\n\t\telse\n\t\t\treturn this.getFirstName().compareTo(s.getFirstName());\n\t}\n}</pre>\n</div></div><h4 id=\"JavaInitial-Comparator\">Comparator</h4><p>Cette interface représente un ordre de tri quelconque. Elle est utile pour permettre le tri d'objets qui n'implémente pas l'interface Comparable ou pour définir un ordre de tri différent de celui défini avec Comparable ( l'interface Comparable représente un ordre naturel : il ne peut y en avoir qu'un)</p><p>Cette interface ne définit qu'une seule méthode : int compare(Object, Object).</p><p>Cette méthode compare les deux objets fournis en paramètres et renvoie :</p><ul><li><p>une valeur entière négative si le premier objet est inférieur au second</p></li><li><p>une valeur entière positive si le premier objet est supérieur au second</p></li><li><p>une valeur nulle si les deux objets sont égaux</p></li></ul><div class=\"code panel pdl conf-macro output-block\" style=\"border-width: 1px;\" data-hasbody=\"true\" data-macro-name=\"code\" data-macro-id=\"0ec1f0a8-cbb8-4c9b-93f4-0bae089fa81b\"><div class=\"codeContent panelContent pdl\">\n<pre class=\"syntaxhighlighter-pre\" data-syntaxhighlighter-params=\"brush: java; gutter: false; theme: Confluence\" data-theme=\"Confluence\">public class CompareList implements Comparator&lt;SimpleBean&gt; {\n\n\t@Override\n\tpublic int compare(SimpleBean bean1, SimpleBean bean2) {\n\t\treturn bean1.getName().compareTo(bean2.getName());\n\t}\n\n}</pre>\n</div></div><h3 id=\"JavaInitial-Conclusion\">Conclusion</h3><p>Il existe 5 façons de parcourir une collection</p><p>Les boucles avec l’utilisation d’un Iterator</p><p>Due à la limitation des boucles for classiques, la méthode d’un itérateur a été créée pour nous permettre de parcourir tous types de collections. Vous pouvez voir que l’interface Collection exige que toutes les collections dont elle est héritée, doivent implémenter la méthode iterator().</p><p>L’exemple suivant explique le concepte d'itérateur:</p><div class=\"code panel pdl conf-macro output-block\" style=\"border-width: 1px;\" data-hasbody=\"true\" data-macro-name=\"code\" data-macro-id=\"c9ac7033-71dc-4539-b3cf-99f7eae2e301\"><div class=\"codeContent panelContent pdl\">\n<pre class=\"syntaxhighlighter-pre\" data-syntaxhighlighter-params=\"brush: java; gutter: false; theme: Confluence\" data-theme=\"Confluence\">List&lt;Integer&gt; integersList = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12);\nIterator&lt;Integer&gt; it = integersList.iterator();\nlong sum = 0;\nwhile (it.hasNext()) {\n\tint value = it.next();\n\tif (value &lt; 10) {\n\t\tsum += value;\n\t}\n}</pre>\n</div></div><p>Les boucles classiques (while, for, do...while)</p><div class=\"code panel pdl conf-macro output-block\" style=\"border-width: 1px;\" data-hasbody=\"true\" data-macro-name=\"code\" data-macro-id=\"5a8228aa-02ae-4c5a-ab29-6433921af80f\"><div class=\"codeContent panelContent pdl\">\n<pre class=\"syntaxhighlighter-pre\" data-syntaxhighlighter-params=\"brush: java; gutter: false; theme: Confluence\" data-theme=\"Confluence\">//do while\ndo {//Statements\n}while(boolean_expression)\n\n//while\nwhile(boolean_expression){\n  //Statements\n}\n\n//for\nfor(int i=0; i &lt; numberOfLoop; i++){\n  //Statements\n}</pre>\n</div></div><p>Les boucles simplifiées dites “enhanced-for” qui ne nécessitent de déclaration d’index  </p><div class=\"code panel pdl conf-macro output-block\" style=\"border-width: 1px;\" data-hasbody=\"true\" data-macro-name=\"code\" data-macro-id=\"901b8822-c19e-4b70-804a-4aa0e8df2d2d\"><div class=\"codeContent panelContent pdl\">\n<pre class=\"syntaxhighlighter-pre\" data-syntaxhighlighter-params=\"brush: java; gutter: false; theme: Confluence\" data-theme=\"Confluence\">for (String valueInLoop: myCollection) {\n    //Statements on valueInLoop\n}</pre>\n</div></div><p>Les boucles forEach et l’utilisation des expressions lambda</p><div class=\"code panel pdl conf-macro output-block\" style=\"border-width: 1px;\" data-hasbody=\"true\" data-macro-name=\"code\" data-macro-id=\"5868d260-a92a-4151-82a0-f9689748a006\"><div class=\"codeContent panelContent pdl\">\n<pre class=\"syntaxhighlighter-pre\" data-syntaxhighlighter-params=\"brush: java; gutter: false; theme: Confluence\" data-theme=\"Confluence\">myCollection.forEach(valueInLoop -&gt;{\n\t//Statements on valueInLoop\n});</pre>\n</div></div><h2 id=\"JavaInitial-Atelierpratique:Manipulationdecollectionsd’objets\"><strong>Atelier pratique : </strong><em><strong>Manipulation de collections d’objets</strong></em></h2><h1 id=\"JavaInitial-Gestiondesentrées/sortiesenJava\"><strong>Gestion des entrées / sorties en Java</strong></h1><h2 id=\"JavaInitial-Packagejava.io\"><strong>Package java.io</strong></h2><p>Le package <span style=\"color: rgb(191,38,0);\">java.io</span>  fournit des classes pour les entrées et sorties du système en utilisant les flux de données, la sérialisation et les fichiers systèmes. Nous passerons à travers les méthodes les plus simples et les plus utilisées disponibles dans cette librairie.</p><h3 id=\"JavaInitial-Lasérialisation\">La sérialisation</h3><p>La sérialisation est un procédé introduit dans le JDK version 1.1 qui permet de rendre un objet ou un graphe d'objets de la JVM persistant pour stockage ou échange et vice versa. Cet objet est mis sous une forme sous laquelle il pourra être reconstitué à l'identique. Ainsi il pourra être stocké sur un disque dur ou transmis au travers d'un réseau pour le créer dans une autre JVM. C'est le procédé qui est utilisé, par exemple, par RMI. La sérialisation est aussi utilisée par les beans pour sauvegarder leurs états.</p><span class=\"confluence-embedded-file-wrapper image-right-wrap-wrapper confluence-embedded-manual-size\"><img class=\"confluence-embedded-image image-wrap-right\" width=\"340\" loading=\"lazy\" src=\"https://computhand.atlassian.net/wiki/download/thumbnails/153485313/adJGLodtbPtiQSoasuznsNvh6K4MmVy5Ft-0Q4n3-EJN2tGm6r9EHG9WEM0_MfLVi0BOCfV-wWMoomne5URwYV98nbk_MF7NrV-Y-q1TlXfTOaWbUXubvbHLDqltgK4LJMUO1i7vU24?version=1&amp;modificationDate=1590093509334&amp;cacheVersion=1&amp;api=v2&amp;width=340&amp;height=140\" data-image-src=\"https://computhand.atlassian.net/wiki/download/attachments/153485313/adJGLodtbPtiQSoasuznsNvh6K4MmVy5Ft-0Q4n3-EJN2tGm6r9EHG9WEM0_MfLVi0BOCfV-wWMoomne5URwYV98nbk_MF7NrV-Y-q1TlXfTOaWbUXubvbHLDqltgK4LJMUO1i7vU24?version=1&amp;modificationDate=1590093509334&amp;cacheVersion=1&amp;api=v2\" data-height=\"245\" data-width=\"592\" data-unresolved-comment-count=\"0\" data-linked-resource-id=\"193724453\" data-linked-resource-version=\"1\" data-linked-resource-type=\"attachment\" data-linked-resource-default-alias=\"adJGLodtbPtiQSoasuznsNvh6K4MmVy5Ft-0Q4n3-EJN2tGm6r9EHG9WEM0_MfLVi0BOCfV-wWMoomne5URwYV98nbk_MF7NrV-Y-q1TlXfTOaWbUXubvbHLDqltgK4LJMUO1i7vU24\" data-base-url=\"https://computhand.atlassian.net/wiki\" data-linked-resource-content-type=\"image/png\" data-linked-resource-container-id=\"153485313\" data-linked-resource-container-version=\"17\" data-media-id=\"9b6937f0-d955-4231-8823-1fb17fc61361\" data-media-type=\"file\" srcset=\"https://computhand.atlassian.net/wiki/download/thumbnails/153485313/adJGLodtbPtiQSoasuznsNvh6K4MmVy5Ft-0Q4n3-EJN2tGm6r9EHG9WEM0_MfLVi0BOCfV-wWMoomne5URwYV98nbk_MF7NrV-Y-q1TlXfTOaWbUXubvbHLDqltgK4LJMUO1i7vU24?version=1&amp;modificationDate=1590093509334&amp;cacheVersion=1&amp;api=v2&amp;width=592&amp;height=245 2x, https://computhand.atlassian.net/wiki/download/thumbnails/153485313/adJGLodtbPtiQSoasuznsNvh6K4MmVy5Ft-0Q4n3-EJN2tGm6r9EHG9WEM0_MfLVi0BOCfV-wWMoomne5URwYV98nbk_MF7NrV-Y-q1TlXfTOaWbUXubvbHLDqltgK4LJMUO1i7vU24?version=1&amp;modificationDate=1590093509334&amp;cacheVersion=1&amp;api=v2&amp;width=340&amp;height=140 1x\"></span><p>L’attribut <strong>serialVersionUID</strong> permet de vérifier que la classe desérialisée est bien du même type que l’objet dans lequel ces valeurs sont insérées.</p><p /><h3 id=\"JavaInitial-LesI/Ostreams\">Les I/O streams</h3><p>Les flux (streams en anglais) permettent d'encapsuler ces processus d'envoi et de réception de données. Les flux traitent toujours les données de façon séquentielle.</p><p>En Java, les flux peuvent être divisés en plusieurs catégories :</p><ul><li><p>les flux d'entrée (input stream) et les flux de sortie (output stream)</p></li><li><p>les flux de traitement de caractères et les flux de traitement d'octets</p></li></ul><p>Java définit des flux pour lire ou écrire des données mais aussi des classes qui permettent de faire des traitements sur les données du flux. Ces classes doivent être associées à un flux de lecture ou d'écriture et sont considérées comme des filtres. Par exemple, il existe des filtres qui permettent de mettre les données traitées dans un tampon (buffer) pour les traiter par lots.</p><h4 id=\"JavaInitial-InputStream\">InputStream</h4><p>Cette classe abstraite définit les fonctions de lecture. Elle possèdent des méthodes lisant une série d'octets (byte).</p><p> </p><div class=\"table-wrap\"><table data-layout=\"default\" class=\"confluenceTable\"><colgroup><col style=\"width: 340.0px;\"/><col style=\"width: 340.0px;\"/></colgroup><tbody><tr><td data-highlight-colour=\"#cacaca\" class=\"confluenceTd\"><p>Méthodes</p></td><td data-highlight-colour=\"#cacaca\" class=\"confluenceTd\"><p>Rôles</p></td></tr><tr><td data-highlight-colour=\"#ffffff\" class=\"confluenceTd\"><p><a href=\"https://docs.oracle.com/javase/7/docs/api/java/io/InputStream.html#available()\" class=\"external-link\" rel=\"nofollow\">available</a>()</p></td><td data-highlight-colour=\"#ffffff\" class=\"confluenceTd\"><p>Renvoie une estimation du nombre d'octets pouvant être lus (ou ignorés) à partir de ce flux d'entrée sans blocage par la prochaine invocation d'une méthode pour ce flux d'entrée.</p></td></tr><tr><td data-highlight-colour=\"#e0e0e0\" class=\"confluenceTd\"><p><a href=\"https://docs.oracle.com/javase/7/docs/api/java/io/InputStream.html#close()\" class=\"external-link\" rel=\"nofollow\">close</a>()</p></td><td data-highlight-colour=\"#e0e0e0\" class=\"confluenceTd\"><p>Ferme ce flux d'entrée et libère toutes les ressources système associées au flux.</p></td></tr><tr><td data-highlight-colour=\"#ffffff\" class=\"confluenceTd\"><p><a href=\"https://docs.oracle.com/javase/7/docs/api/java/io/InputStream.html#mark(int)\" class=\"external-link\" rel=\"nofollow\">mark</a>(int readlimit)</p></td><td data-highlight-colour=\"#ffffff\" class=\"confluenceTd\"><p>Marque la position courant dans le flux</p></td></tr><tr><td data-highlight-colour=\"#e0e0e0\" class=\"confluenceTd\"><p><a href=\"https://docs.oracle.com/javase/7/docs/api/java/io/InputStream.html#markSupported()\" class=\"external-link\" rel=\"nofollow\">markSupported</a>()</p></td><td data-highlight-colour=\"#e0e0e0\" class=\"confluenceTd\"><p>Test si le flux supporte les méthodes mark et reset.</p></td></tr><tr><td data-highlight-colour=\"#ffffff\" class=\"confluenceTd\"><p><a href=\"https://docs.oracle.com/javase/7/docs/api/java/io/InputStream.html#read()\" class=\"external-link\" rel=\"nofollow\">read</a>()</p></td><td data-highlight-colour=\"#ffffff\" class=\"confluenceTd\"><p>Lit le prochain de byte de données dans le flux</p></td></tr><tr><td data-highlight-colour=\"#e0e0e0\" class=\"confluenceTd\"><p><a href=\"#\" rel=\"nofollow\">read</a>(byte[] b)</p></td><td data-highlight-colour=\"#e0e0e0\" class=\"confluenceTd\"><p>Lit un certain nombre d'octets dans le flux d'entrée et les stocke dans le tableau de tampons b.</p></td></tr><tr><td data-highlight-colour=\"#ffffff\" class=\"confluenceTd\"><p><a href=\"#\" rel=\"nofollow\">read</a>(byte[] b, int off, int len)</p></td><td data-highlight-colour=\"#ffffff\" class=\"confluenceTd\"><p>Lit jusqu'à len octets de données du flux d'entrée dans un tableau d'octets.</p></td></tr><tr><td data-highlight-colour=\"#e0e0e0\" class=\"confluenceTd\"><p><a href=\"https://docs.oracle.com/javase/7/docs/api/java/io/InputStream.html#reset()\" class=\"external-link\" rel=\"nofollow\">reset</a>()</p></td><td data-highlight-colour=\"#e0e0e0\" class=\"confluenceTd\"><p>Repositionne ce flux à la position au moment où la méthode mark a été appelée pour la dernière fois sur ce flux d'entrée.</p></td></tr><tr><td data-highlight-colour=\"#ffffff\" class=\"confluenceTd\"><p><a href=\"https://docs.oracle.com/javase/7/docs/api/java/io/InputStream.html#skip(long)\" class=\"external-link\" rel=\"nofollow\">skip</a>(long n)</p></td><td data-highlight-colour=\"#ffffff\" class=\"confluenceTd\"><p>Ignore et supprime n octets de données de ce flux d'entrée.</p></td></tr></tbody></table></div><h4 id=\"JavaInitial-OutputStream\">OutputStream</h4><p>Cette classe abstraite définit les fonctions d’écriture. Elle possèdent des méthodes écrivant une série d'octets (byte).</p><p> </p><div class=\"table-wrap\"><table data-layout=\"default\" class=\"confluenceTable\"><colgroup><col style=\"width: 340.0px;\"/><col style=\"width: 340.0px;\"/></colgroup><tbody><tr><td data-highlight-colour=\"#cacaca\" class=\"confluenceTd\"><p>Méthodes</p></td><td data-highlight-colour=\"#cacaca\" class=\"confluenceTd\"><p>Rôles</p></td></tr><tr><td data-highlight-colour=\"#ffffff\" class=\"confluenceTd\"><p><a href=\"https://docs.oracle.com/javase/7/docs/api/java/io/OutputStream.html#close()\" class=\"external-link\" rel=\"nofollow\">close</a>()</p></td><td data-highlight-colour=\"#ffffff\" class=\"confluenceTd\"><p>Ferme ce flux de sortie et libère toutes les ressources système associées à ce flux.</p></td></tr><tr><td data-highlight-colour=\"#e0e0e0\" class=\"confluenceTd\"><p><a href=\"https://docs.oracle.com/javase/7/docs/api/java/io/OutputStream.html#flush()\" class=\"external-link\" rel=\"nofollow\">flush</a>()</p></td><td data-highlight-colour=\"#e0e0e0\" class=\"confluenceTd\"><p>Vide ce flux de sortie et force l'écriture de tous les octets de sortie mis en mémoire tampon.</p></td></tr><tr><td data-highlight-colour=\"#ffffff\" class=\"confluenceTd\"><p><a href=\"#\" rel=\"nofollow\">write</a>(byte[] b)</p></td><td data-highlight-colour=\"#ffffff\" class=\"confluenceTd\"><p>Écrit des octets b.length du tableau d'octets spécifié dans ce flux de sortie.</p></td></tr><tr><td data-highlight-colour=\"#e0e0e0\" class=\"confluenceTd\"><p><a href=\"#\" rel=\"nofollow\">write</a>(byte[] b, int off, int len)</p></td><td data-highlight-colour=\"#e0e0e0\" class=\"confluenceTd\"><p>Écrit len octets du tableau d'octets spécifié en commençant à l'offset off dans ce flux de sortie.</p></td></tr><tr><td data-highlight-colour=\"#ffffff\" class=\"confluenceTd\"><p><a href=\"https://docs.oracle.com/javase/7/docs/api/java/io/OutputStream.html#write(int)\" class=\"external-link\" rel=\"nofollow\">write</a>(int b)</p></td><td data-highlight-colour=\"#ffffff\" class=\"confluenceTd\"><p>Écrit l'octet b spécifié dans ce flux de sortie.</p></td></tr></tbody></table></div><p><br/></p><h3 id=\"JavaInitial-Laconsole\">La console</h3><p>La classe <span style=\"color: rgb(191,38,0);\">java.io.Console</span>, ajoutée dans Java SE 6, permet un accès à la console du système d'exploitation pour permettre la saisie ou l'affichage de données. Cette nouvelle classe fait usage des flux de type Reader et Writer ce qui permet une gestion correcte des caractères.</p><p>La classe System possède une méthode <span style=\"color: rgb(191,38,0);\">console() </span>qui permet d'obtenir une instance de la classe Console.</p><p>La méthode <span style=\"color: rgb(191,38,0);\">printf()</span> permet de formater et d'afficher des données.</p><p>La méthode <span style=\"color: rgb(191,38,0);\">readLine()</span> permet la saisie d'une ligne de données dont les caractères sont affichés sur la console.</p><p>La méthode <span style=\"color: rgb(191,38,0);\">readPassword()</span> est identique à la méthode <span style=\"color: rgb(191,38,0);\">readLine() </span>mais les caractères saisis ne sont pas affichés sur la console.</p><h3 id=\"JavaInitial-Lectureetécrituredefichiers\"><strong>Lecture et écriture de fichiers</strong></h3><p>Les fichiers et les répertoires sont encapsulés dans la classe File du package <span style=\"color: rgb(191,38,0);\">java.io</span>. Il n'existe pas de classe pour traiter les répertoires car ils sont considérés comme des fichiers. Une instance de la classe File est une représentation logique d'un fichier ou d'un répertoire qui peut ne pas exister physiquement sur le disque.</p><p>Si le fichier ou le répertoire existe, de nombreuses méthodes de la classe File permettent d'obtenir des informations sur le fichier. Sinon plusieurs méthodes permettent de créer des fichiers ou des répertoires.</p><p>Depuis la version 1.2 du J.D.K., de nombreuses fonctionnalités ont été ajoutées à cette classe :</p><ul><li><p>la création de fichiers temporaires (createNewFile, createTempFile, deleteOnExit)</p></li><li><p>la gestion des attributs &quot;caché&quot; et &quot;lecture seule&quot; (isHidden, isReadOnly)</p></li><li><p>des méthodes qui renvoient des objets de type File au lieu du type String ( getParentFile, getAbsoluteFile, getCanonicalFile, listFiles)</p></li><li><p>une méthode qui renvoie le fichier sous forme d'URL (toURL)</p></li></ul><h4 id=\"JavaInitial-LaclasseReader\">La classe Reader</h4><p> C'est une classe abstraite qui est la classe mère de toutes les classes qui gèrent des flux de caractères en lecture.</p><p>Cette classe définit plusieurs méthodes :<br/></p><div class=\"table-wrap\"><table data-layout=\"default\" class=\"confluenceTable\"><colgroup><col style=\"width: 214.0px;\"/><col style=\"width: 545.0px;\"/></colgroup><tbody><tr><td data-highlight-colour=\"#cacaca\" class=\"confluenceTd\"><p>Méthodes</p></td><td data-highlight-colour=\"#cacaca\" class=\"confluenceTd\"><p>Rôles</p></td></tr><tr><td data-highlight-colour=\"#ffffff\" class=\"confluenceTd\"><p>boolean markSupported()</p></td><td data-highlight-colour=\"#ffffff\" class=\"confluenceTd\"><p>indique si le flux supporte la possibilité de marquer des positions</p></td></tr><tr><td data-highlight-colour=\"#e0e0e0\" class=\"confluenceTd\"><p>boolean ready()</p></td><td data-highlight-colour=\"#e0e0e0\" class=\"confluenceTd\"><p>indique si le flux est prêt à être lu</p></td></tr><tr><td data-highlight-colour=\"#ffffff\" class=\"confluenceTd\"><p>close()</p></td><td data-highlight-colour=\"#ffffff\" class=\"confluenceTd\"><p>ferme le flux et libère les ressources qui lui étaient associées</p></td></tr><tr><td data-highlight-colour=\"#e0e0e0\" class=\"confluenceTd\"><p>int read()</p></td><td data-highlight-colour=\"#e0e0e0\" class=\"confluenceTd\"><p>renvoie le caractère lu ou -1 si la fin du flux est atteinte.</p></td></tr><tr><td data-highlight-colour=\"#ffffff\" class=\"confluenceTd\"><p>int read(char[])</p></td><td data-highlight-colour=\"#ffffff\" class=\"confluenceTd\"><p>lire plusieurs caractères et les mettre dans un tableau de caractères</p></td></tr><tr><td data-highlight-colour=\"#e0e0e0\" class=\"confluenceTd\"><p>int read(char[], int, int)</p></td><td data-highlight-colour=\"#e0e0e0\" class=\"confluenceTd\"><p>lire plusieurs caractères. Elle attend en paramètre : un tableau de caractères qui contiendra les caractères lus, l'indice du premier élément du tableau qui recevra le premier caractère et le nombre de caractères à lire. Elle renvoie le nombre de caractères lus ou -1 si aucun caractère n'a été lu. Le tableau de caractères contient les caractères lus.</p></td></tr><tr><td data-highlight-colour=\"#ffffff\" class=\"confluenceTd\"><p>long skip(long)</p></td><td data-highlight-colour=\"#ffffff\" class=\"confluenceTd\"><p>saute autant de caractères dans le flux que la valeur fournie en paramètre. Elle renvoie le nombre de caractères sautés.</p></td></tr><tr><td data-highlight-colour=\"#e0e0e0\" class=\"confluenceTd\"><p>mark()</p></td><td data-highlight-colour=\"#e0e0e0\" class=\"confluenceTd\"><p>permet de marquer une position dans le flux</p></td></tr><tr><td data-highlight-colour=\"#ffffff\" class=\"confluenceTd\"><p>reset()</p></td><td data-highlight-colour=\"#ffffff\" class=\"confluenceTd\"><p>retourne dans le flux à la dernière position marquée</p></td></tr></tbody></table></div><p>Pour lire un fichier, il faut utiliser plusieurs classes différentes dont un <span style=\"color: rgb(191,38,0);\">File </span>et un <span style=\"color: rgb(191,38,0);\">FileReader </span>classe fille de <span style=\"color: rgb(191,38,0);\">Reader</span>. Exemple:</p><div class=\"code panel pdl conf-macro output-block\" style=\"border-width: 1px;\" data-hasbody=\"true\" data-macro-name=\"code\" data-macro-id=\"104410be-beb3-48e2-8c64-bb70c3fcf3b2\"><div class=\"codeContent panelContent pdl\">\n<pre class=\"syntaxhighlighter-pre\" data-syntaxhighlighter-params=\"brush: java; gutter: false; theme: Confluence\" data-theme=\"Confluence\">//Creates a FileReader Object\nFile myFile = new File(&quot;pathToTheFile&quot;);\nFileReader fr = new FileReader(myFile);\n\nchar[] a = new char[50];\nfr.read(a) // reads the 50 first char of the file and put it in the array\n\nfor(char c : a)\n  System.out.println(c); //prints the readed chars one by one\n\nfr.closes();</pre>\n</div></div><p>Le <span style=\"color: rgb(191,38,0);\">File </span>sert à représenter un fichier sur le disque. Le <span style=\"color: rgb(191,38,0);\">FileReader </span>reçoit le <span style=\"color: rgb(191,38,0);\">File </span>en argument et représente le <span style=\"color: rgb(191,38,0);\">FileInputStream </span>qui sera utilisé pour lire le fichier. Vous pourriez lire le fichier à l'aide du FileReader. On utilisera un tableau de caractère pour récupérer le contenu du fichier et l’afficher.</p><h4 id=\"JavaInitial-LaclasseWritter\">La classe Writter</h4><p>C'est une classe abstraite qui est la classe mère de toutes les classes qui gèrent des flux de caractères en écriture.</p><p>Cette classe définit plusieurs méthodes :</p><div class=\"table-wrap\"><table data-layout=\"default\" class=\"confluenceTable\"><colgroup><col style=\"width: 340.0px;\"/><col style=\"width: 340.0px;\"/></colgroup><tbody><tr><td data-highlight-colour=\"#cacaca\" class=\"confluenceTd\"><p>Méthodes</p></td><td data-highlight-colour=\"#cacaca\" class=\"confluenceTd\"><p>Rôles</p></td></tr><tr><td data-highlight-colour=\"#ffffff\" class=\"confluenceTd\"><p>close()</p></td><td data-highlight-colour=\"#ffffff\" class=\"confluenceTd\"><p>ferme le flux et libère les ressources qui lui étaient associées</p></td></tr><tr><td data-highlight-colour=\"#e0e0e0\" class=\"confluenceTd\"><p>write(int)</p></td><td data-highlight-colour=\"#e0e0e0\" class=\"confluenceTd\"><p>écrire le caractère en paramètre dans le flux.</p></td></tr><tr><td data-highlight-colour=\"#ffffff\" class=\"confluenceTd\"><p>write(char[])</p></td><td data-highlight-colour=\"#ffffff\" class=\"confluenceTd\"><p>écrire le tableau de caractères en paramètre dans le flux.</p></td></tr><tr><td data-highlight-colour=\"#e0e0e0\" class=\"confluenceTd\"><p>write(char[], int, int)</p></td><td data-highlight-colour=\"#e0e0e0\" class=\"confluenceTd\"><p>écrire plusieurs caractères. Elle attend en paramètres : un tableau de caractères, l'indice du premier caractère et le nombre de caractères à écrire.</p></td></tr><tr><td data-highlight-colour=\"#ffffff\" class=\"confluenceTd\"><p>write(String)</p></td><td data-highlight-colour=\"#ffffff\" class=\"confluenceTd\"><p>écrire la chaîne de caractères en paramètre dans le flux</p></td></tr><tr><td data-highlight-colour=\"#e0e0e0\" class=\"confluenceTd\"><p>write(String, int, int)</p></td><td data-highlight-colour=\"#e0e0e0\" class=\"confluenceTd\"><p>écrire une portion d'une chaîne de caractères. Elle attend en paramètre : une chaîne de caractères, l'indice du premier caractère et le nombre de caractères à écrire.</p></td></tr></tbody></table></div><p><br/>Pour écrire dans un fichier, il y aura sensiblement le même travail. Il vous faudra, comme précédemment, deux classes différentes, un File et un FileWriter. Exemple:</p><div class=\"code panel pdl conf-macro output-block\" style=\"border-width: 1px;\" data-hasbody=\"true\" data-macro-name=\"code\" data-macro-id=\"e4815b9d-f4ae-46a3-8232-c5670c4e9251\"><div class=\"codeContent panelContent pdl\">\n<pre class=\"syntaxhighlighter-pre\" data-syntaxhighlighter-params=\"brush: java; gutter: false; theme: Confluence\" data-theme=\"Confluence\">File file = new File(&quot;test.txt&quot;);\n\n//create the file\nfile.createNewFile();\n\n//create a FileWriter Object\nFileWriter writer = new FileWriter(file);\n\n//Writes the content to the file\nwriter.write(&quot;This\\n is\\n an \\n example\\n&quot;);\nwriter.flush();\nwriter.close();</pre>\n</div></div><p>Le <span style=\"color: rgb(191,38,0);\">File </span>sert à représenter un fichier sur le disque. Le <span style=\"color: rgb(191,38,0);\">FileWriter </span>reçoit le File en argument et représente le <span style=\"color: rgb(191,38,0);\">FileOutputStream </span>qui sera utilisé pour écrire dans le fichier. Vous pourriez écrire dans le fichier à l'aide du <span style=\"color: rgb(191,38,0);\">FileWriter</span>.</p><h3 id=\"JavaInitial-Utilisationdebuffers\"><strong>Utilisation de buffers</strong></h3><p>Pour améliorer les performances des flux sur un fichier, la mise en tampon des données lues ou écrites permet de traiter un ensemble de caractères représentant une ligne plutôt que de traiter les données caractères par caractères. Le nombre d'opérations est ainsi réduit.</p><p>Les classes BufferedReader et BufferedWriter permettent de gérer des flux de caractères tamponnés avec des fichiers.</p><h4 id=\"JavaInitial-LaclasseBufferReader\">La classe BufferReader</h4><p>Il faut instancier un objet de la classe BufferedReader. Cette classe possède plusieurs constructeurs qui peuvent tous lever une exception de type <span style=\"color: rgb(191,38,0);\">FileNotFoundException</span>:<br/> </p><div class=\"table-wrap\"><table data-layout=\"default\" class=\"confluenceTable\"><colgroup><col style=\"width: 340.0px;\"/><col style=\"width: 340.0px;\"/></colgroup><tbody><tr><td data-highlight-colour=\"#cacaca\" class=\"confluenceTd\"><p><strong>Constructeur</strong></p></td><td data-highlight-colour=\"#cacaca\" class=\"confluenceTd\"><p><strong>Rôle</strong></p></td></tr><tr><td data-highlight-colour=\"#ffffff\" class=\"confluenceTd\"><p>BufferedReader(Reader)</p></td><td data-highlight-colour=\"#ffffff\" class=\"confluenceTd\"><p>le paramètre fourni doit correspondre au flux à lire.</p></td></tr><tr><td data-highlight-colour=\"#e0e0e0\" class=\"confluenceTd\"><p>BufferedReader(Reader, int)</p></td><td data-highlight-colour=\"#e0e0e0\" class=\"confluenceTd\"><p>l'entier en paramètre permet de préciser la taille du buffer. Il doit être positif sinon une exception de type IllegalArgumentException est levée.</p></td></tr></tbody></table></div><p /><div class=\"code panel pdl conf-macro output-block\" style=\"border-width: 1px;\" data-hasbody=\"true\" data-macro-name=\"code\" data-macro-id=\"cf8d2f92-9e6b-4a71-ac0a-0ba1b8390fb5\"><div class=\"codeContent panelContent pdl\">\n<pre class=\"syntaxhighlighter-pre\" data-syntaxhighlighter-params=\"brush: java; gutter: false; theme: Confluence\" data-theme=\"Confluence\">File file = new File(&quot;src/module3/example-out.txt&quot;);\nFileWriter writer = new FileWriter(file);\nBufferedWriter buffer = new BufferedWriter(writer);\nbuffer.write(&quot;Hello&quot;);\nbuffer.newLine();\nbuffer.write(&quot;Programming&quot;);\nbuffer.newLine();\nbuffer.write(&quot;World&quot;);\nbuffer.newLine();\nbuffer.close;\n</pre>\n</div></div><p>En utilisant un <span style=\"color: rgb(191,38,0);\">BufferedWriter</span>, vous pourrez mettre en mémoire les choses à écrire et <strong>flusher</strong> au besoin ou à la toute fin. Une autre considération est que le <span style=\"color: rgb(191,38,0);\">BufferedWriter </span>vous permettra d'appeler <span style=\"color: rgb(191,38,0);\">newline()</span> à chaque fin de ligne, plutôt que de le faire vous même en envoyant les caractères de saut et retour à chaque fois.</p><h4 id=\"JavaInitial-LaclasseBufferWriter\">La classe BufferWriter</h4><p>Il faut instancier un objet de la classe BufferedWriter. Cette classe possède plusieurs constructeurs :</p><p> </p><div class=\"table-wrap\"><table data-layout=\"default\" class=\"confluenceTable\"><colgroup><col style=\"width: 340.0px;\"/><col style=\"width: 340.0px;\"/></colgroup><tbody><tr><td data-highlight-colour=\"#cacaca\" class=\"confluenceTd\"><p><strong>Constructeur</strong></p></td><td data-highlight-colour=\"#cacaca\" class=\"confluenceTd\"><p><strong>Rôle</strong></p></td></tr><tr><td data-highlight-colour=\"#ffffff\" class=\"confluenceTd\"><p>BufferedWriter(Writer)</p></td><td data-highlight-colour=\"#ffffff\" class=\"confluenceTd\"><p>le paramètre fourni doit correspondre au flux dans lequel les données sont écrites.</p></td></tr><tr><td data-highlight-colour=\"#e0e0e0\" class=\"confluenceTd\"><p>BufferedWriter(Writer, int)</p></td><td data-highlight-colour=\"#e0e0e0\" class=\"confluenceTd\"><p>l'entier en paramètre permet de préciser la taille du buffer. Il doit être positif sinon une exception IllegalArgumentException est levée.</p><p><br/></p></td></tr></tbody></table></div><p /><div class=\"code panel pdl conf-macro output-block\" style=\"border-width: 1px;\" data-hasbody=\"true\" data-macro-name=\"code\" data-macro-id=\"3a313f4e-f841-40d5-80cd-12738a6eea63\"><div class=\"codeContent panelContent pdl\">\n<pre class=\"syntaxhighlighter-pre\" data-syntaxhighlighter-params=\"brush: java; gutter: false; theme: Confluence\" data-theme=\"Confluence\">File file = new File(&quot;src/module3/example.txt&quot;);\nFileReader reader = new FileReader(file);\nBufferedReader buffer = new BufferedReader(reader);\nString line;\nwhile((line = buffer.readLine()) != null) {\n    System.out.println(line);\n}\nbuffer.close();</pre>\n</div></div><p>Le <span style=\"color: rgb(191,38,0);\">BufferedReader </span>lira octet par octet jusqu'au prochain changement de ligne et attendra pour lire la prochaine ligne pour vous.</p><p>Lorsque la ligne sera <span style=\"color: rgb(191,38,0);\">null</span>, c'est alors que le fichier est terminé.</p><h4 id=\"JavaInitial-LesfichiersXML\">Les fichiers XML</h4><p>Voici un exemple d’un fichier XML, Le XML ou eXtensible Markup Language est un langage informatique de balisage générique:</p><div class=\"code panel pdl conf-macro output-block\" style=\"border-width: 1px;\" data-hasbody=\"true\" data-macro-name=\"code\" data-macro-id=\"1ca0d83f-42dc-439b-986a-7c58c2c15b3a\"><div class=\"codeContent panelContent pdl\">\n<pre class=\"syntaxhighlighter-pre\" data-syntaxhighlighter-params=\"brush: xml; gutter: false; theme: Confluence\" data-theme=\"Confluence\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;CATALOG&gt;\n    &lt;CD&gt;\n        &lt;TITLE&gt;Empire Burlesque&lt;/TITLE&gt;\n        &lt;ARTIST&gt;Bob Dylan&lt;/ARTIST&gt;\n        &lt;COUNTRY&gt;USA&lt;/COUNTRY&gt;\n        &lt;COMPANY&gt;Columbia&lt;/COMPANY&gt;\n        &lt;PRICE&gt;10.90&lt;/PRICE&gt;\n        &lt;YEAR&gt;1985&lt;/YEAR&gt;\n    &lt;/CD&gt;\n    &lt;CD&gt;\n        &lt;TITLE&gt;Hide your heart&lt;/TITLE&gt;\n        &lt;ARTIST&gt;Bonnie Tyler&lt;/ARTIST&gt;\n        &lt;COUNTRY&gt;UK&lt;/COUNTRY&gt;\n        &lt;COMPANY&gt;CBS Records&lt;/COMPANY&gt;\n        &lt;PRICE&gt;9.90&lt;/PRICE&gt;\n        &lt;YEAR&gt;1988&lt;/YEAR&gt;\n    &lt;/CD&gt;\n&lt;/CATALOG&gt;\n</pre>\n</div></div><h5 id=\"JavaInitial-Unlangagedebalisagegénérique:\"><strong>Un langage de balisage générique:</strong></h5><p>Un langage de balisage est un langage qui s'écrit grâce à des balises. Ces balises permettent de structurer de manière hiérarchisée et organisée les données d'un document.</p><p>Le terme générique signifie que nous allons pouvoir définir nos propres balise via un fichier dtd afin de définir la balise ses attributs et ses propriétés</p><h5 id=\"JavaInitial-SonObjectif:\"><strong>Son Objectif:</strong></h5><p>Décrire les données de manière aussi bien compréhensible par les hommes qui écrivent les documents XML que par les machines qui les exploitent.</p><p>Le XML se veut également compatible avec le web afin que les échanges de données puissent se faire facilement à travers le réseau Internet.</p><p>Le XML se veut donc standardisé, simple, mais surtout extensible et configurable afin que n'importe quel type de données puisse être décrit.</p><p><br/>Pour lire un fichier XML, il faut utiliser une librairie de lecture (un DOM parser). Il en existe de nombreuses! Voici un exemple simple avec le DOM parser fourni avec Java qui lit le document précédemment montré en exemple</p><p>On aura besoin des classes suivantes pour lire le fichier</p><div class=\"code panel pdl conf-macro output-block\" style=\"border-width: 1px;\" data-hasbody=\"true\" data-macro-name=\"code\" data-macro-id=\"2d4842f2-ee74-4d6f-b2e0-892e02378878\"><div class=\"codeContent panelContent pdl\">\n<pre class=\"syntaxhighlighter-pre\" data-syntaxhighlighter-params=\"brush: java; gutter: false; theme: Confluence\" data-theme=\"Confluence\">import javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.DocumentBuilder;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.NodeList;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.Element;\nimport java.io.File;</pre>\n</div></div><p>Comme n’importe quel fichier on utilise la classe File pour charger le fichier, on utilisera par la suite les classes DocumentBuilderFactory et DocumentBuilder pour parser notre Fichier XML:</p><div class=\"code panel pdl conf-macro output-block\" style=\"border-width: 1px;\" data-hasbody=\"true\" data-macro-name=\"code\" data-macro-id=\"2ab69cf0-2436-46c5-9e9a-32a4aee80d4c\"><div class=\"codeContent panelContent pdl\">\n<pre class=\"syntaxhighlighter-pre\" data-syntaxhighlighter-params=\"brush: java; gutter: false; theme: Confluence\" data-theme=\"Confluence\">// Exemple de lecture\nFile xmlFile = new File(&quot;src/module3/example.xml&quot;);\nDocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\nDocumentBuilder dBuilder = dbFactory.newDocumentBuilder();\nDocument doc = dBuilder.parse(xmlFile);</pre>\n</div></div><p>Utiliser les differentes classes de lecture de noeud pour pouvoir parcourir votre Fichier XML:</p><div class=\"code panel pdl conf-macro output-block\" style=\"border-width: 1px;\" data-hasbody=\"true\" data-macro-name=\"code\" data-macro-id=\"4b13c8ff-67c6-4c5f-8183-fb87169505e5\"><div class=\"codeContent panelContent pdl\">\n<pre class=\"syntaxhighlighter-pre\" data-syntaxhighlighter-params=\"brush: java; gutter: false; theme: Confluence\" data-theme=\"Confluence\">System.out.println(&quot;Root element :&quot; + doc.getDocumentElement().getNodeName());\nNodeList nList = doc.getElementsByTagName(&quot;CD&quot;);\nSystem.out.println(&quot;----------------------------&quot;);\nfor (int temp = 0; temp &lt; nList.getLength(); temp++) {\n    Node nNode = nList.item(temp);                \n    System.out.println(&quot;\\nCurrent Element :&quot; + nNode.getNodeName());                \n    if (nNode.getNodeType() == Node.ELEMENT_NODE) {\n        Element eElement = (Element) nNode;\n        System.out.println(&quot;TITLE: &quot; + eElement.getElementsByTagName(&quot;TITLE&quot;).item(0).getTextContent());\n        System.out.println(&quot;ARTIST: &quot; + eElement.getElementsByTagName(&quot;ARTIST&quot;).item(0).getTextContent());\n        System.out.println(&quot;COUNTRY: &quot; + eElement.getElementsByTagName(&quot;COUNTRY&quot;).item(0).getTextContent());\n        System.out.println(&quot;COMPANY: &quot; + eElement.getElementsByTagName(&quot;COMPANY&quot;).item(0).getTextContent());\n        System.out.println(&quot;PRICE: &quot; + eElement.getElementsByTagName(&quot;PRICE&quot;).item(0).getTextContent());\n        System.out.println(&quot;YEAR: &quot; + eElement.getElementsByTagName(&quot;YEAR&quot;).item(0).getTextContent());\n    }\n}</pre>\n</div></div><h3 id=\"JavaInitial-Jeudecaractèresetencodage\"><strong>Jeu de caractères et encodage</strong></h3><p>Un jeu de caractères est un ensemble de caractères. Dans un jeu, chaque caractère est associé à une valeur unique.</p><p>Les jeux de caractères les plus utilisés dans les pays occidentaux sont notamment ISO-8859-1, ISO-8859-15, UTF-8, Windows CP-1252, ...</p><p>Un caractère est une unité minimale abstraite de texte qui n'a pas forcément toujours la même représentation graphique.</p><p>La plate-forme Java utilise Unicode pour son support des caractères mais il est fréquent de devoir traiter des données textuelles encodées différemment en entrée ou en sortie d'une application. Java propose plusieurs classes et méthodes pour permettre la conversion de nombreux encodages de caractères de et vers Unicode.</p><p>Les applications Java qui doivent traiter des données non encodées en Unicode, sont lues avec l'encodage adéquat, stockées et traitées en Unicode et exportent le résultat de Unicode vers l'encodage initial ou l'encodage cible.</p><p>La plupart des classes que nous avons précédemment support la spécification d’un paramètre pour définir l’encodage de l'élément d'entrées ou de sortie.</p><h3 id=\"JavaInitial-Gestiondeslogs:java.util.logging\"><strong>Gestion des logs : java.util.logging</strong></h3><p>Le logging est une activité technique utile et nécessaire dans une application pour :</p><ul><li><p>Déboguer : pratique lorsque la mise en oeuvre d'un débogueur n'est pas facile.</p></li><li><p>Obtenir des traces d'exécution (démarrage/arrêt, informations, avertissements, erreurs d'exécution, ...</p></li><li><p>Faciliter la recherche d'une source d'anomalie (stacktrace, ...)</p></li><li><p>Comprendre ou vérifier le flux des traitements exécutés : traces des entrées/sorties dans les méthodes, affichage de la pile d'appels</p></li></ul><p>L'importance du logging croît avec la taille et la complexité de l'application qui l'utilise.</p><h4 id=\"JavaInitial-Logging-Fonctionnement\">Logging - Fonctionnement</h4><p>Une API de logging fait généralement intervenir trois composants principaux :</p><ul><li><p>Logger : invoqué pour émettre grâce au framework un message généralement avec un niveau de gravité associé</p></li><li><p>Formatter : utilisé pour formater le contenu du message</p></li><li><p>Appender/Handler : utilisé pour envoyer le message à une cible de stockage (console, fichier, base de données, email, ...)</p></li></ul><p>Le logging doit faire partie intégrante des fonctionnalités d'une application. Bien sûr le niveau de gravité des messages n'est pas le même en développement et en production mais le code de l'application doit rester le même. Seule la configuration du logging doit changer dans les différents environnements.</p><p>Généralement la configuration peut être externalisée dans un fichier ce qui rend l'utilisation de l'API plus souple et flexible.</p><p>La modification de la configuration du logging en cours d'exécution de l'application (soit dynamiquement soit par rechargement de la configuration) est importante pour permettre d'avoir couramment un niveau de log acceptable et, au besoin, un niveau de log plus fin sans devoir relancer l'application.</p><p>Les API de logging ont plusieurs inconvénients :</p><ul><li><p>Il faut définir avec précision les messages à ajouter dans les journaux et la pertinence des informations qu'ils contiennent</p></li><li><p>Il faut définir avec précision le niveau de gravité des messages</p></li><li><p>L'utilisation d'une API de logging peut dégrader les performances d'une application</p></li></ul><p>Le logging est particulièrement important dans une application notamment côté serveur mais une utilisation à outrance ou une mauvaise utilisation de cette fonctionnalité peut dégrader les performances générales de l'application.</p><p>Les frameworks de logging sont conçus pour limiter la consommation en ressources nécessaires à leur mise en oeuvre mais cette consommation existe tout de même et croît naturellement avec le nombre de messages émis.</p><p>L'utilisation d'une API de Logging implique donc une surcharge de consommation de ressources (CPU, mémoire, ...) mais elle se justifie par l'apport des informations fournies en cas de problème sous réserve que ces informations aient été judicieusement choisies.</p><h4 id=\"JavaInitial-Desrecommandationslorsdelamiseenoeuvre\"><br/>Des recommandations lors de la mise en oeuvre</h4><p>Voici quelques règles pour une bonne mise en oeuvre du logging :</p><ul><li><p>Chaque message doit contenir la date/heure d'émission et la classe émettrice</p></li><li><p>Ne jamais utiliser de System.out pour afficher des messages mais utiliser une API de Logging</p></li><li><p>Ne jamais utiliser la méthode printStackTrace() de la classe Exception pour afficher des messages mais utiliser une API de Logging</p></li><li><p>Eviter les messages émis trop fréquemment (par exemple dans une boucle avec un nombre important d'itérations ou dans une méthode fréquemment invoquée, ...)</p></li><li><p>Utiliser le niveau de gravité en adéquation avec le message</p></li><li><p>Faire attention aux informations affichées. (message en info qui donne une indication sur le code, de l’information sensible, info utilisateur,...)</p></li></ul><p>Pour des traces d'exécution, il est pratique d'émettre un message en début d'une méthode qui affiche les paramètres en entrée et un message à la fin de la méthode avec la valeur de retour</p><h4 id=\"JavaInitial-LoggingvsSysout\"><br/>Logging vs Sysout</h4><p>Il est fortement recommandé d'utiliser une API de logging plutôt que d'utiliser la méthode System.out.println() pour plusieurs raisons :</p><ul><li><p>Une API de logging permet un contrôle sur le format des messages en proposant un format standard pouvant inclure des données telles que la date/heure, la classe, le thread, ...</p></li><li><p>Une API de logging permet de gérer différentes cibles de stockage des messages</p></li><li><p>Une API de logging permet de modifier à l'exécution le niveau de gravité des messages pris en compte</p></li></ul><p>Sur des applications utilisées par plusieurs utilisateurs, par exemple une application web, il peut être très utile de faire figurer dans le message une identité sur le responsable de l'action (par exemple, l'adresse IP d'une requête http).</p><h4 id=\"JavaInitial-java.util.logging\"><br/>java.util.logging<br/></h4><p>API basique intégré dans le JRE de Java. Toutes les écritures de message sont faites via l’instance du Logger. Les Loggers rassemblent l’information qui doit être écrite dans un LogRecord. </p><span class=\"confluence-embedded-file-wrapper image-right-wrap-wrapper confluence-embedded-manual-size\"><img class=\"confluence-embedded-image image-wrap-right\" width=\"340\" loading=\"lazy\" src=\"https://computhand.atlassian.net/wiki/download/thumbnails/153485313/_P9Nuo7btkEjvJWQPoNILzkGKpinxDnFLN3ik52Z1VlKsC7D4wYavZ4JAIFQRZ4soV8SWntDUL_5a9Odc2X1qjHijG5ZUemuFDp1dnUBiivBBH_08DM_2ZkjVJPdkSJkbkduU8WV08Y?version=1&amp;modificationDate=1590099162473&amp;cacheVersion=1&amp;api=v2&amp;width=340&amp;height=136\" data-image-src=\"https://computhand.atlassian.net/wiki/download/attachments/153485313/_P9Nuo7btkEjvJWQPoNILzkGKpinxDnFLN3ik52Z1VlKsC7D4wYavZ4JAIFQRZ4soV8SWntDUL_5a9Odc2X1qjHijG5ZUemuFDp1dnUBiivBBH_08DM_2ZkjVJPdkSJkbkduU8WV08Y?version=1&amp;modificationDate=1590099162473&amp;cacheVersion=1&amp;api=v2\" data-height=\"215\" data-width=\"535\" data-unresolved-comment-count=\"0\" data-linked-resource-id=\"194117706\" data-linked-resource-version=\"1\" data-linked-resource-type=\"attachment\" data-linked-resource-default-alias=\"_P9Nuo7btkEjvJWQPoNILzkGKpinxDnFLN3ik52Z1VlKsC7D4wYavZ4JAIFQRZ4soV8SWntDUL_5a9Odc2X1qjHijG5ZUemuFDp1dnUBiivBBH_08DM_2ZkjVJPdkSJkbkduU8WV08Y\" data-base-url=\"https://computhand.atlassian.net/wiki\" data-linked-resource-content-type=\"image/png\" data-linked-resource-container-id=\"153485313\" data-linked-resource-container-version=\"17\" data-media-id=\"7424cea6-14e7-44a2-a69b-a481f54337a8\" data-media-type=\"file\" srcset=\"https://computhand.atlassian.net/wiki/download/thumbnails/153485313/_P9Nuo7btkEjvJWQPoNILzkGKpinxDnFLN3ik52Z1VlKsC7D4wYavZ4JAIFQRZ4soV8SWntDUL_5a9Odc2X1qjHijG5ZUemuFDp1dnUBiivBBH_08DM_2ZkjVJPdkSJkbkduU8WV08Y?version=1&amp;modificationDate=1590099162473&amp;cacheVersion=1&amp;api=v2&amp;width=535&amp;height=215 2x, https://computhand.atlassian.net/wiki/download/thumbnails/153485313/_P9Nuo7btkEjvJWQPoNILzkGKpinxDnFLN3ik52Z1VlKsC7D4wYavZ4JAIFQRZ4soV8SWntDUL_5a9Odc2X1qjHijG5ZUemuFDp1dnUBiivBBH_08DM_2ZkjVJPdkSJkbkduU8WV08Y?version=1&amp;modificationDate=1590099162473&amp;cacheVersion=1&amp;api=v2&amp;width=340&amp;height=136 1x\"></span><p /><p>Le LogReccord est alors transféré à un Handler. L’Handler détermine quoi faire avec le LogRecord. Par exemple, le LogRecord peut être écrit sur le disque ou envoyé via le réseau à un système de surveillance.</p><p>Le Logger et le Handler, tous deux peuvent passer le LogRecord à travers une classe de type Filter qui détermine si le LogRecord doit être transféré ou non.</p><p>Un Handler peut également utiliser une classe de type Fomatter pour formater le LogRecord en chaîne de caractères avant de l'envoyer à un fichier ou système externe.</p><h4 id=\"JavaInitial-LogLevel\"><br/>Log Level</h4><p>Quelque soit le message écrit, ce message est écrit avec un certain niveau de sévérité. Ce niveau est un entier qui détermine quelle importance a ce message. Plus le chiffre (niveau) est grand, plus le message est important.</p><p>Un Logger peut avoir un niveau minimum d'écriture défini, qui détermine si le message est transféré à un Handler ou non. Ce n’est pas un filtre, même si c’est le même comportement. Par exemple, tous les message sous un certain niveau peuvent ne pas être pris en compte dans l'écriture des logs de l’application.</p><h4 id=\"JavaInitial-LogHierarchy\"><br/>Log Hierarchy</h4><p>Les instances du Logger sont organisées en hiérarchie. Il existe 7 niveaux de log dans l’API. Ils permettent de filtrer ou d’afficher ou non un niveau de log. La configuration détermine un niveau de log à afficher, elle est gérée par le LogManager. Tous les niveaux plus bas ne seront pas affichés:</p><ul><li><p> SEVERE (highest value)</p></li><li><p> WARNING</p></li><li><p> INFO</p></li><li><p> CONFIG</p></li><li><p> FINE</p></li><li><p> FINER</p></li><li><p> FINEST  (lowest value)</p></li></ul><h1 id=\"JavaInitial-Javaetlesbasesdedonnées\"><strong>Java et les bases de données</strong></h1><h2 id=\"JavaInitial-Principedel’APIJDBC\"><strong>Principe de l’API JDBC</strong></h2><h3 id=\"JavaInitial-Définition.7\">Définition</h3><p><strong>JDBC</strong> est un acronyme pour <strong>Java Database Connectivity</strong>. Il est le morceau de technologie le plus bas dans la chaîne qui permet à Java de se connecter aux bases de données. Il fournit une interface, assez complexe, mais unifiée pour tous les fournisseurs de base de données. Grâce à<strong> JDBC</strong>, vous pouvez vous connecter à une base de données <strong>MySQL, Oracle, MSSQL, SQLite</strong> sans difficulté.</p><p>Pour fonctionner, <strong>JDBC</strong> doit obtenir des <strong>pilotes</strong> qui font le pont entre <strong>JDBC</strong> et le serveur de base de données. La plupart de ces pilotes sont disponibles en dépendance ouverte (open source) que vous pouvez obtenir grâce à une simple recherche sur Internet.</p><h3 id=\"JavaInitial-Utilisation\">Utilisation</h3><p>Toutes les classes de JDBC sont dans le package java.sql. Il faut donc l'importer dans tous les programmes devant utiliser JDBC.</p><p>Il y a 4 classes importantes : DriverManager, Connection, Statement (et PreparedStatement), et ResultSet, chacune correspondant à une étape de l'accès aux données :</p><div class=\"table-wrap\"><table data-layout=\"default\" class=\"confluenceTable\"><colgroup><col style=\"width: 340.0px;\"/><col style=\"width: 340.0px;\"/></colgroup><tbody><tr><td data-highlight-colour=\"#cacaca\" class=\"confluenceTd\"><p><strong>Classe</strong></p></td><td data-highlight-colour=\"#cacaca\" class=\"confluenceTd\"><p><strong>Rôle</strong></p></td></tr><tr><td data-highlight-colour=\"#ffffff\" class=\"confluenceTd\"><p>DriverManager</p></td><td data-highlight-colour=\"#ffffff\" class=\"confluenceTd\"><p>Charger et configurer le driver de la base de données.</p></td></tr><tr><td data-highlight-colour=\"#e0e0e0\" class=\"confluenceTd\"><p>Connection</p></td><td data-highlight-colour=\"#e0e0e0\" class=\"confluenceTd\"><p>Réaliser la connexion et l'authentification à la base de données.</p></td></tr><tr><td data-highlight-colour=\"#ffffff\" class=\"confluenceTd\"><p>Statement (et PreparedStatement)</p></td><td data-highlight-colour=\"#ffffff\" class=\"confluenceTd\"><p>Contenir la requête SQL et la transmettre à la base de données.</p></td></tr><tr><td data-highlight-colour=\"#e0e0e0\" class=\"confluenceTd\"><p>ResultSet</p></td><td data-highlight-colour=\"#e0e0e0\" class=\"confluenceTd\"><p>Parcourir les informations retournées par la base de données dans le cas d'une sélection de données</p></td></tr></tbody></table></div><p><br/>Chacune de ces classes dépend de l'instanciation d'un objet de la précédente classe.</p><p><a href=\"/wiki/spaces/FD/pages/188055553/Installation+SQLite\" data-linked-resource-id=\"188055553\" data-linked-resource-version=\"1\" data-linked-resource-type=\"page\">Installation SQLite</a> </p><h3 id=\"JavaInitial-InstallationduJDBCSQLite\">Installation du JDBC SQLite</h3><p>Pour démarrer un projet avec <strong>JDBC</strong> et <strong>SQLite</strong>, il faut premièrement créer un projet vide comme vous avez déjà fait par le passé. Ensuite, il faut copier le pilote<strong> SQLite</strong> que nous avons téléchargé précédemment dans un nouveau répertoire sous src que nous appellerons lib. Par la suite, vous devrez aller configurer le <strong>&quot;build path&quot;</strong> de votre application en cliquant, avec le bouton droit, sur le nom de votre projet et ensuite choisir l'option Build path -&gt; Configure Build Path. Vous aurez ensuite une fenêtre comme celle-ci:</p><p>Sous Libraries, cliquez sur le noeud Classpath et ensuite sur Add External JARs. Trouvez le sqlite-jdbc-X.X.X.X.jar que vous avez téléchargé précédemment et ajoutez le.</p><h2 id=\"JavaInitial-Seconnecteràunebase\"><strong>Se connecter à une base</strong></h2><h3 id=\"JavaInitial-ConnexionavecSQLite\">Connexion avec SQLite</h3><p>Pour commencer avec <strong>JDBC</strong> et un pilote, il faut créer une connexion vers la base de données. Dans le cas de <strong>SQLite</strong>, si la base de donnée n'existe pas, elle sera créée. Donc, à moins que le fichier existe et qu'il ne soit pas une base de données <strong>SQLite</strong> ou si le chemin d'accès n'existe pas, vous ne devriez pas avoir à gérer d'exceptions.</p><div class=\"code panel pdl conf-macro output-block\" style=\"border-width: 1px;\" data-hasbody=\"true\" data-macro-name=\"code\" data-macro-id=\"233c511e-a248-4524-a740-346df2822fe8\"><div class=\"codeContent panelContent pdl\">\n<pre class=\"syntaxhighlighter-pre\" data-syntaxhighlighter-params=\"brush: java; gutter: false; theme: Confluence\" data-theme=\"Confluence\">Connection conn = DriverManager.getConnection(&quot;jdbc:sqlite:test.db&quot;);\nconn.close();</pre>\n</div></div><p>Un exemple de classe de connecteur</p><div class=\"code panel pdl conf-macro output-block\" style=\"border-width: 1px;\" data-hasbody=\"true\" data-macro-name=\"code\" data-macro-id=\"446010d3-d0d5-405a-b288-a319675c673b\"><div class=\"codeContent panelContent pdl\">\n<pre class=\"syntaxhighlighter-pre\" data-syntaxhighlighter-params=\"brush: java; gutter: false; theme: Confluence\" data-theme=\"Confluence\">import java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\nimport java.util.logging.Logger;\n\npublic class SQLiteConnector {\n\tprivate String dbName;\n\tpublic Connection connection;\n\tprivate Statement requete;\n\t\n\tprivate static final Logger LOG = Logger.getLogger(&quot;SQLiteConnector.class&quot;);\n\t\n\t/**\n\t * Constructeur de la classe Database\n\t * \n\t * @param dbName Le nom de la base de données\n\t */\n\tpublic SQLiteConnector(String dbName) {\n\t\t// Charge le driver sqlite JDBC en utilisant le class loader actuel\n\t\ttry {\n\t\t\tClass.forName(&quot;org.sqlite.JDBC&quot;);\n\t\t} catch (ClassNotFoundException e1) {\n\t\t\tLOG.severe(e1.getMessage());\n\t\t}\n\n\t\tthis.dbName = dbName;\n\t\tthis.connection = null;\n\t}\n\n\t/**\n\t * Ouvre la base de données spécifiée\n\t * \n\t * @return True si la connection à été réussie. False sinon.\n\t */\n\tpublic boolean connect() {\n\t\ttry {\n\t\t\t// Etabli la connection\n\t\t\tconnection = DriverManager.getConnection(&quot;jdbc:sqlite:&quot; + this.dbName);\n\t\t\t// Déclare l'objet qui permet de faire les requêtes\n\t\t\trequete = connection.createStatement();\n\n\t\t\t// Le PRAGMA synchronous de SQLite permet de vérifier chaque écriture\n\t\t\t// avant d'en faire une nouvelle.\n\t\t\t// Le PRAGMA count_changes de SQLite permet de compter le nombre de\n\t\t\t// changements fait sur la base\n\t\t\t// Résultats de mes tests :\n\t\t\t// synchronous OFF, une insertion est 20 fois plus rapide.\n\t\t\t// La différences avec le count_changes est de l'ordre de la µs.\n\t\t\t// Les autres PRAGMA : http://www.sqlite.org/pragma.html\n\n\t\t\trequete.executeUpdate(&quot;PRAGMA synchronous = OFF;&quot;);\n\t\t\trequete.setQueryTimeout(30);\n\n\t\t\treturn true;\n\t\t} catch (SQLException e) {\n\t\t\t// message = &quot;out of memory&quot; souvent le resultat de la BDD pas trouvée\n\t\t\tLOG.severe(e.getMessage());\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Ferme la connection à la base de données\n\t * \n\t * @return True si la connection a bien été fermée. False sinon.\n\t */\n\tpublic boolean disconnect() {\n\t\ttry {\n\t\t\tif (connection != null)\n\t\t\t\tconnection.close();\n\n\t\t\treturn true;\n\t\t} catch (SQLException e) {\n\t\t\tLOG.severe(e.getMessage());\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Permet de faire une requête SQL\n\t * \n\t * @param requete La requête SQL (avec un &quot;;&quot; à la fin)\n\t * @return Un ResultSet contenant le résultat de la requête\n\t */\n\tpublic ResultSet getResultOf(String requete) {\n\t\ttry {\n\t\t\treturn this.requete.executeQuery(requete);\n\t\t} catch (SQLException e) {\n\t\t\tLOG.severe(e.getMessage());\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Permet de modifier une entrée de la base de données.&lt;/br&gt;\n\t * \n\t * @param requete La requete SQL de modification\n\t */\n\tpublic void updateValue(String requete) {\n\t\ttry {\n\t\t\tthis.requete.executeUpdate(requete);\n\t\t} catch (SQLException e) {\n\t\t\tLOG.severe(e.getMessage());\n\t\t}\n\t}</pre>\n</div></div><h2 id=\"JavaInitial-Récupérerdesdonnéesd’unebase\"><strong>Récupérer des données d’une base</strong></h2><p>Une fois la connexion établie, il est possible d'exécuter des ordres SQL. Les objets qui peuvent être utilisés pour obtenir des informations sur la base de données sont :</p><div class=\"table-wrap\"><table data-layout=\"default\" class=\"confluenceTable\"><colgroup><col style=\"width: 340.0px;\"/><col style=\"width: 340.0px;\"/></colgroup><tbody><tr><td data-highlight-colour=\"#cacaca\" class=\"confluenceTd\"><p><strong>Classe</strong></p></td><td data-highlight-colour=\"#cacaca\" class=\"confluenceTd\"><p><strong>Rôle</strong></p></td></tr><tr><td data-highlight-colour=\"#ffffff\" class=\"confluenceTd\"><p>DatabaseMetaData</p></td><td data-highlight-colour=\"#ffffff\" class=\"confluenceTd\"><p>informations à propos de la base de données : nom des tables, index, version ...</p></td></tr><tr><td data-highlight-colour=\"#e0e0e0\" class=\"confluenceTd\"><p>ResultSet</p></td><td data-highlight-colour=\"#e0e0e0\" class=\"confluenceTd\"><p>résultat d'une requête et information sur une table. L'accès se fait enregistrement par enregistrement.</p></td></tr><tr><td data-highlight-colour=\"#ffffff\" class=\"confluenceTd\"><p>ResultSetMetaData</p></td><td data-highlight-colour=\"#ffffff\" class=\"confluenceTd\"><p>informations sur les colonnes (nom et type) d'un ResultSet</p></td></tr></tbody></table></div><h2 id=\"JavaInitial-Lierlesdonnéesd’unebaseavecdesobjetsJava\"><strong>Lier les données d’une base avec des objets Java</strong></h2><h3 id=\"JavaInitial-CorrespondanceJava↔︎Table\">Correspondance Java ↔︎ Table</h3><p>Il existe une grande panoplie de fonctions disponibles pour lire les champs d'un <span style=\"color: rgb(191,38,0);\">ResultSet</span>. Notez qu'en <strong>JDBC</strong>, les index de champs commencent par <span style=\"color: rgb(191,38,0);\">1</span>, pas par <span style=\"color: rgb(191,38,0);\">0</span>. Si vous voulez lire un résultat dans un objet, par exemple une classe <span style=\"color: rgb(191,38,0);\">User </span>que vous auriez créée, alors il vous faudrait un constructeur pour cette classe, par exemple:</p><div class=\"code panel pdl conf-macro output-block\" style=\"border-width: 1px;\" data-hasbody=\"true\" data-macro-name=\"code\" data-macro-id=\"aea82c7c-d9b1-4741-841d-6c39b7f7a08c\"><div class=\"codeContent panelContent pdl\">\n<pre class=\"syntaxhighlighter-pre\" data-syntaxhighlighter-params=\"brush: java; gutter: false; theme: Confluence\" data-theme=\"Confluence\">public class User {\n    // Propriétées\n    public User (int id, String firstname, String lastname, int age) {\n        // Code\n    }\n}</pre>\n</div></div><p>Et dans la boucle, vous pourriez utiliser une collection pour stocker les résultats:</p><div class=\"code panel pdl conf-macro output-block\" style=\"border-width: 1px;\" data-hasbody=\"true\" data-macro-name=\"code\" data-macro-id=\"1d60177f-c684-4ce1-9a78-16bd1c9c4013\"><div class=\"codeContent panelContent pdl\">\n<pre class=\"syntaxhighlighter-pre\" data-syntaxhighlighter-params=\"brush: java; gutter: false; theme: Confluence\" data-theme=\"Confluence\">while (results.next() ) {\n    users.add(new User(\n        results.getInt(1),\n        results.getString(2),\n        results.getString(3),\n        results.getInt(4)\n    ));\n}</pre>\n</div></div><h3 id=\"JavaInitial-PatrondeconceptionDAO\">Patron de conception DAO</h3><p>On pourra utiliser le patron de conception DAO pour lier nos objets aux tables.</p><p>Ce pattern permet de faire le lien entre la couche d'accès aux données et la couche métier d'une application (vos classes). Il permet de mieux maîtriser les changements susceptibles d'être opérés sur le système de stockage des données ; donc, par extension, de préparer une migration d'un système à un autre (BDD vers fichiers XML, par exemple…). Ceci se fait en séparant accès aux données (BDD) et objets métiers (POJO).</p><h2 id=\"JavaInitial-Insérerdesdonnéesdanslabase\"><strong>Insérer des données dans la base</strong></h2><h3 id=\"JavaInitial-excuteUpdate()\">excuteUpdate()</h3><p>La méthode executeUpdate() retourne le nombre d'enregistrements qui ont été mis à jour</p><div class=\"code panel pdl conf-macro output-block\" style=\"border-width: 1px;\" data-hasbody=\"true\" data-macro-name=\"code\" data-macro-id=\"0a7a777e-0910-48b4-9972-517b936e669e\"><div class=\"codeContent panelContent pdl\">\n<pre class=\"syntaxhighlighter-pre\" data-syntaxhighlighter-params=\"brush: java; gutter: false; theme: Confluence\" data-theme=\"Confluence\">String request = &quot;INSERT INTO CLIENT VALUES (3, 'client 3', 'prenom 3')&quot;;\ntry{\n  //conn = DriverManager.getConnection(&quot;jdbc:DATABASETYPE:DATABASENAME&quot;));\n  Statement stmt = conn.createStatement();\n  int nbMaj = stmt.executeUpdate(request);\n  system.out.println(&quot;nb mise à jour = &quot; + nbMaj);\n} catch(SQLException ex){\n  //TODO generated better to manage with log\n  ex.printStackTrace();\n}</pre>\n</div></div><p>Lorsque la méthode executeUpdate() est utilisée pour exécuter un traitement de type DDL ( Data Definition Langage : définition de données ) comme la création d'une table, elle retourne 0. Si la méthode retourne 0, cela peut signifier deux choses : le traitement de mise à jour n'a affecté aucun enregistrement ou le traitement concernait un traitement de type DDL.</p><h3 id=\"JavaInitial-SQLExceptionsuiteàuneinsertion\">SQLException suite à une insertion</h3><p>Si l'on utilise executeQuery() pour exécuter une requête SQL ne contenant pas d'ordre SELECT, alors une exception de type SQLException est levée.</p><div class=\"code panel pdl conf-macro output-block\" style=\"border-width: 1px;\" data-hasbody=\"true\" data-macro-name=\"code\" data-macro-id=\"a2cdcbbe-694b-4ffb-ab56-a54c0a570eec\"><div class=\"codeContent panelContent pdl\">\n<pre class=\"syntaxhighlighter-pre\" data-syntaxhighlighter-params=\"brush: java; gutter: false; theme: Confluence\" data-theme=\"Confluence\">String request = &quot;INSERT INTO CLIENT VALUES (4, 'client 4', 'prenom 4')&quot;;\ntry{\n  //conn = DriverManager.getConnection(&quot;jdbc:DATABASETYPE:DATABASENAME&quot;));\n  Statement stmt = conn.createStatement();\n  int nbMaj = stmt.executeQuery(request);\n  system.out.println(&quot;nb mise à jour = &quot; + nbMaj);\n} catch(SQLException ex){\n  //TODO generated better to manage with log\n  ex.printStackTrace();\n}</pre>\n</div></div><p>Résultat:</p><div class=\"code panel pdl conf-macro output-block\" style=\"border-width: 1px;\" data-hasbody=\"true\" data-macro-name=\"code\" data-macro-id=\"f17a9cf3-c51c-49c0-8aaf-7bb56d15dd86\"><div class=\"codeContent panelContent pdl\">\n<pre class=\"syntaxhighlighter-pre\" data-syntaxhighlighter-params=\"brush: powershell; gutter: false; theme: Confluence\" data-theme=\"Confluence\">java.sql.SQLException: No ResultSet was produced\njava.lang.Throwable(java.lang.String)\njava.lang.Exception(java.lang.String)\njava.sql.SQLException(java.lang.String)\njava.sql.ResultSet sun.jdbc.odbc.JdbcOdbcStatement.executeQuery(java.lang.String)\nvoid testjdbc.TestJDBC1.main(java.lang.String [])</pre>\n</div></div><div class=\"confluence-information-macro confluence-information-macro-note conf-macro output-block\" data-hasbody=\"true\" data-macro-name=\"note\" data-macro-id=\"859982af-094b-445d-b409-fd4d251d094d\"><span class=\"aui-icon aui-icon-small aui-iconfont-warning confluence-information-macro-icon\"> </span><div class=\"confluence-information-macro-body\"><p>Dans ce cas la requête est quand même effectuée. Dans l'exemple, un nouvel enregistrement est créé dans la table<span style=\"color: rgb(255,255,255);\">.</span></p></div></div><p> </p><p />","representation":"view","_expandable":{"webresource":"","embeddedContent":"","mediaToken":"","content":"/rest/api/content/153485313"}},"_expandable":{"editor":"","atlas_doc_format":"","export_view":"","styled_view":"","dynamic":"","storage":"","editor2":"","anonymous_export_view":""}},"extensions":{"position":423},"_expandable":{"childTypes":"","container":"/rest/api/space/FD","metadata":"","operations":"","schedulePublishDate":"","children":"/rest/api/content/153485313/child","restrictions":"/rest/api/content/153485313/restriction/byOperation","history":"/rest/api/content/153485313/history","ancestors":"","version":"","descendants":"/rest/api/content/153485313/descendant","space":"/rest/api/space/FD"},"_links":{"self":"https://computhand.atlassian.net/wiki/rest/api/content/153485313","tinyui":"/x/AQAmCQ","editui":"/pages/resumedraft.action?draftId=153485313","webui":"/spaces/FD/pages/153485313/Java+Initial"}}],"start":0,"limit":25,"size":1,"_links":{"base":"https://computhand.atlassian.net/wiki","context":"/wiki","self":"https://computhand.atlassian.net/wiki/rest/api/content?spacekey=FD&expand=body.view&title=Java+Initial"}}